;;;*****************************************************************************
;;;
;;;; Hacks for html-helper-mode extensions.
;;;
;;;    Tags in tag lists were generated by looking at the
;;; http://werbach.com/barebones/ pages.
;;;
;;;    The fact that the tags database are indentified by path rather than file
;;; name (see the rgr-html-flush-buffer-anchors-internal function) is something
;;; of a kludge.  Nothing can get into this database at present without being in
;;; a file buffer, so using the file name makes much more sense, particularly
;;; since it would allow us to handle buffers that are not in the server public
;;; tree, which we can't do at present.  -- rgr, 3-Feb-99.
;;;
;;;    Modification history:
;;;
;;; . . .
;;; rgr-html-check-buffer-hrefs: first (+/-) working version.  -- rgr, 5-Aug-97.
;;; rgr-html-check-buffer-hrefs: now handles all site-local references,
;;;	uses comprehensive url parsing & tag database.  -- rgr, 25-Aug-97.
;;; list files in rgr-html-check-buffer-hrefs, minor chgs.  -- rgr, 26-Aug-97.
;;; rgr-html-check-buffer-hrefs proceed option, rgr-html-flush-all-anchors,
;;;	buffer hooks, misc cleanup.  -- rgr, 27-Aug-97.
;;; rgr-html-check-buffer-hrefs: no output if no undefs.  -- rgr, 4-Sep-97.
;;; rhsap struct, rgr-html-local-server-p, attempting rfc1808 cleanups on
;;;	rgr-html-parse-http-url, user-mail-address hack.  -- rgr, 23-Sep-97.
;;; rgr-html-local-url-p: fix bug in abs paths, rgr-html-check-buffer-hrefs area
;;;	tags, new rgr-html-update-all-buffer-anchors cmd.  -- rgr, 19-Jan-98.
;;; deleted much obsolete stuff.  -- rgr, 21-Jan-98.
;;; rgr-html-href-target allows whitespace, fix rgr-html-update-buffer-anchors
;;;	name bug.  -- rgr, 26-Jan-98.
;;; rgr-html-update-buffer-anchors: use rgr-html-parse-tag-attributes to extract
;;;	anchor names.  -- rgr, 25-Apr-98.
;;; rgr-html-href-regexp: also match <img src="ref">.  -- rgr, 8-Jan-99.
;;; rgr-html-check-directory-hrefs: crude directory checker.  -- rgr, 8-Jan-99.
;;; compilation-mode interface for rgr-html-check-buffer-hrefs and
;;;	rgr-html-check-directory-hrefs, etc.  -- rgr, 30-Jan-99.
;;; rgr-html-check-directory-hrefs: give the bufs unique names, other
;;;	format tweaking.  -- rgr, 2-Feb-99.
;;; rgr-html-file-url: root dir list, never return nil, show unreferenced files
;;;	in rgr-html-check-directory-hrefs cmd, sort buffers.  -- rgr, 3-Feb-99.
;;; rgr-html-print-undefined-url: string url bug kludge.  -- rgr, 22-Feb-99.
;;; rgr-html-same-directory-p: fix: check len before substring, remodularized
;;;	rgr-html-file-url, handle rgr-html-check-directory-hrefs symlinks, add
;;;	apache root.  -- rgr, 6-Apr-00.
;;; rgr-html-maybe-fix-url-p, rgr-pluralize: eql -> eq.  -- rgr, 1-May-00.
;;; fix home compile/load problem, no # or ~ in unref files.  -- rgr, 27-May-00.
;;; rgr-html-local-url-p: teach this about index.* files.  -- rgr, 15-Jun-00.
;;; implicit page names in rgr-html-find-local-anchor, make fragments
;;;	case-insensitive when parsing, ispell-quit.  -- rgr, 7-Nov-00.
;;; rgr-html-define-server: replace hardwired servers.  -- rgr, 20-Nov-00.
;;; reorder rgr-html-local-server-access-paths to fix cwarn.  -- rgr, 22-Nov-00.
;;; rgr-html-maybe-update-file-anchors: symlink kludge.  -- rgr, 28-Nov-00.
;;; really make tags case-insensitive.  -- rgr, 21-Feb-02.
;;; (require 'psa-defstruct) at load-time, too.  -- rgr, 16-Mar-02.
;;;
;;; $Id$

(require 'html-helper-mode)
(require 'rgr-html-hacks)
(require 'psa-defstruct)
(eval-when-compile
  (require 'rgr-html-nest))

;;;; URL parsing.

(psa-defstruct (rgr-html-server-access-path (:type list) (:conc-name rhsap-))
  ;; Structure describing how to get to a local server.  Based on the Symbolics
  ;; Lisp Machine "access path" concept.
  server-regexp		;; matches all instances of this server
  server-name		;; canonical name string
  (protocol nil)	;; *string* port, or nil
  (root-directory nil)	;; where the files live (can be ange-ftp path)
  )

(defvar rgr-html-local-server-access-paths nil
  "Database that maps the host name and protocol of http URL's for local
servers to a file name by which the page can be accessed directly.  This
is implemented as a list of rgr-html-server-access-path structures.  The
first entry on this list is taken to be the 'default' local server.
Protocol can be nil to mean unspecified [***bug***: if specified
defaultly], and directory-name can start with ange-ftp (or efs) magic if
the file is not actually mounted via nfs (or whatever).  [new.  -- rgr,
23-Sep-97.]  [the code as written can deal with rhsap-root-directory
slots that are lists of files, to accomodate symbolic links.  but i
haven't actually used this yet, because i'm not comfortable with the
implications.  -- rgr, 3-Feb-99.]  [but there are symbolic links, so i
guess i have to live with it.  -- rgr, 6-Apr-00.]")

(defun rgr-html-local-server-p (server-name &optional protocol)
  "If the specified server is local, then return its access path.
'Local' just means we can find it in the
rgr-html-local-server-access-paths database."
  (let ((result nil) (tail rgr-html-local-server-access-paths))
    (while tail
      (let ((server (car tail)))
	(if (and (string-match (rhsap-server-regexp server) server-name)
		 (or (null (rhsap-protocol server))
		     (equal (rhsap-protocol server) protocol)))
	    (setq result server
		  tail nil)
	    (setq tail (cdr tail)))))
    result))

(defun rgr-html-install-server (server)
  (let ((server-name (rhsap-server-name server))
	(tail rgr-html-local-server-access-paths))
    ;; get rid of any old server with a conflicting name and port.
    (while tail
      (let ((old-server (car tail)))
	(setq tail (cdr tail))
	(if (and (string-match (rhsap-server-regexp old-server) server-name)
		 ;; [the protocol here is really the port number as a string
		 ;; . . .  -- rgr, 20-Nov-00.]
		 (equal (rhsap-protocol old-server) (rhsap-protocol server)))
	    (setq rgr-html-local-server-access-paths
		  (delete old-server rgr-html-local-server-access-paths)))))
    ;; ensure that the server is actually local.
    (let ((server-dirs
	   (if (listp (rhsap-root-directory server))
	       (rhsap-root-directory server)
	       (list (rhsap-root-directory server))))
	  (readable-dirs nil))
      (while server-dirs
	(let ((dir (car server-dirs)))
	  (cond ((not (file-directory-p dir))
		  (message "Warning: %S for %S is not a directory."
			   dir server-name)
		  (sit-for 1))
		((not (file-readable-p dir))
		  (message "Warning: %S for %S is not readable."
			   dir server-name)
		  (sit-for 1))
		(t
		  (setq readable-dirs (cons dir readable-dirs)))))
	(setq server-dirs (cdr server-dirs)))
      (psa-setf (rhsap-root-directory server) readable-dirs))
    ;; add the new one.
    (cond ((rhsap-root-directory server)
	    (setq rgr-html-local-server-access-paths
		  (cons server rgr-html-local-server-access-paths)))
	  (t
	    (message "Warning: Ignoring server %s, which is not local."
		     server-name)
	    (sit-for 1)))
    server-name))

(defmacro rgr-html-define-server (name regexp &rest keyword-options)
  (` (rgr-html-install-server (make-rgr-html-server-access-path
				:server-regexp (, regexp)
				:server-name (, name)
				(,@ keyword-options)))))

(defvar rgr-html-href-regexp
	(let ((whitespace "[ \t\n]"))
	  (concat "<\\(a\\|area\\|img\\)" whitespace "+[^>]*\\(href\\|src\\)"
		  whitespace "*="
		  whitespace "*['\"]\\([^'\"]+\\)['\"]"))
  "Matches a hypertext reference (a, src, or area).  The first subexpression
is the tag, the *third* is the href value.")

(defun rgr-html-href-target ()
  ;; Given that we have just matched rgr-html-href-regexp, return the target
  ;; string, with whitespace squeezed out.
  (let ((target (match-string 3)))
    (save-match-data
      (while (string-match "[ \t\n]+" target)
	(setq target (replace-match "" t t target))))
    target))

(psa-defstruct (rgr-html-url (:type list) (:conc-name rhu-))
  ;; Structure describing a parsed URL.  Based on the Common Lisp "pathname"
  ;; concept.  (Only handles HTTP: "schemes".)  [trying to extend that now.  --
  ;; rgr, 23-Sep-97.]
  (scheme 'http)	;; Symbol denoting scheme (new, incomplete).
  host			;; web server host name
  (protocol nil)	;; *string* port, or nil
  (path nil)		;; "/foo/bar.html" for absolute path
  (searchpart nil)	;; stuff after question mark
  (fragment nil)	;; not part of the url, strictly.
  )

(defun rgr-html-empty-url-p (url)
  ;; Returns non-nil if given an empty URL.
  (and (null (rhu-host url))
       ;; if host is null, then so must be protocol.
       (null (rhu-path url)) (null (rhu-searchpart url))
       (null (rhu-fragment url))))

(psa-defstruct (rgr-html-anchor (:conc-name rha-))
  ;; Structure describing a particular <a name="foo"> construct.
  (name nil)		;; string, e.g. "foo" from "#foo"
  (url nil)		;; [currently parsed and merged.  -- rgr, 25-Aug-97.]
  (where nil)		;; marker (or point) for in a buffer, cons of
			;;   (file-name . name) for local page, nil for when the
			;;   buffer is killed or anything else.
  (refs 0)		;; count of refs (list would be more $$ but useful).
  )

(defun rgr-html-anchor-file-name (anchor)
  ;; Given an anchor, return the file name (if we can).
  (let ((where (rha-where anchor)))
    (cond ((null where) nil)
	  ((markerp where) (buffer-file-name (marker-buffer where)))
	  ((consp where) (car where)))))

(defmacro rgr-html-trailing-field-parsef (url-string match-string)
  ;; url-string may be shortened (by assignment to the variable) in the process.
  ;; the extracted trailing field is returned.  null string is same as not
  ;; specified.
  (` (let ((<found-p> (string-match (, match-string) (, url-string)))
	   (<result> nil))
       (cond (<found-p>
	       (setq <result> (substring (, url-string) (1+ <found-p>)))
	       (setq (, url-string) (substring (, url-string) 0 <found-p>))))
       (if (equal <result> "") nil <result>))))

(defun rgr-html-parse-http-url (url-string)
  ;; This version is based on RFC 1808
  ;; ("http://www.w3.org/Addressing/rfc1808.txt") section 2.4.  -- rgr,
  ;; 23-Sep-97.
  (let ((scheme nil) (host nil) (protocol nil) (path nil) (parameters nil)
	(searchpart nil) (fragment nil))
    ;; 2.4.1.  Parsing the fragment.  [We downcase this because fragments are
    ;; case-insensitive, and so it's easiest to standardize case here.  There
    ;; are still random (downcase tag) fragments scattered throughout; these are
    ;; redundant and should be flushed.  -- rgr, 7-Nov-00.]
    (setq fragment (rgr-html-trailing-field-parsef url-string "#"))
    (and fragment
	 (setq fragment (downcase fragment)))
    ;; 2.4.2.  Parsing the scheme.
    (cond ((string-match "^[a-zA-Z0-9-.+]+:" url-string)
	    (setq scheme (substring url-string 0 (1- (match-end 0))))
	    (setq url-string (substring url-string (match-end 0)))))
    ;; 2.4.3.  Parsing the network location/login.
    (if (string-match "^//[^/]+" url-string)
	(let ((netloc (substring url-string 2 (match-end 0)))
	      (start nil))
	  ;; The subsequent / (if any) is part of the path.
	  (setq url-string (substring url-string (match-end 0)))
	  (cond ((setq start (string-match ":[0-9]+$" netloc))
		  (setq host (substring netloc 0 start))
		  (setq protocol (string-to-int (substring netloc (1+ start)))))
		(t
		  (setq host netloc protocol nil)))))
    ;; 2.4.4.  Parsing the query information.  [we're calling this the
    ;; searchpart.  -- rgr, 23-Sep-97.]
    (setq searchpart (rgr-html-trailing-field-parsef url-string "\\?"))
    ;; 2.4.5.  Parsing the parameters
    (setq parameters (rgr-html-trailing-field-parsef url-string ";"))
    ;; 2.4.6.  Parsing the path.
    (setq path (if (equal url-string "") nil url-string))
    (make-rgr-html-url :host host
		       :protocol protocol
		       :path path
		       :searchpart searchpart
		       :fragment fragment)))

(defun rgr-html-parse-url (url-string)
  ;; General URL parser (impoverished first version).  -- rgr, 25-Aug-97.
  (let* ((type
	   (if (string-match "^[a-zA-Z0-9-+.]+:" url-string)
	       ;; "scheme" production of rfc1808.
	       (intern (downcase (substring url-string 0 (1- (match-end 0)))))
	       ;; assume we're dealing with HTTP.
	       'http))
	 (parsers '((http . rgr-html-parse-http-url)))
	 (parser (assoc type parsers)))
    (and parser
	 (funcall (cdr parser) url-string))))

(defun rgr-html-merge-url (url &optional default)
  ;; [the default default to merge against is the local server, but that may not
  ;; be best.  -- rgr, 23-Sep-97.]  [***bug***: rfc1808 specifies merging as
  ;; part of the parsing process, sorta.  in any case it's not exactly what we
  ;; have here.  -- rgr, 23-Sep-97.]
  (if (stringp url)
      (setq url (rgr-html-parse-url url)))
  (if url
      (let* ((default-server (car rgr-html-local-server-access-paths))
	     (host (or (rhu-host url)
		       (and default (rhu-host default))
		       (rhsap-server-name default-server)))
	     (protocol (or (rhu-protocol url)
			   (and default (rhu-protocol default))
			   (rhsap-protocol default-server)))
	     (access-path (rgr-html-local-server-p host protocol))
	     (path (or (rhu-path url)
		       (and default (rhu-path default))))
	     (searchpart (or (rhu-searchpart url)
			     (and default (rhu-searchpart default)))))
	(cond (access-path
		;; Canonicalize host.
		(setq host (rhsap-server-name access-path))
		;; Given that this is the local server, we can do something
		;; intelligent about the path.
		(cond ((< (length path) 1)
			;; bug; this is really just a guess.
			(setq path "welcome.html"))
		      ((= (aref path 0) ?/)
			;; "Absolute" pathname; don't need to fix it up.
			)
		      (t
			;; Relative syntax.
			(let* ((default-dir
				 (or (if (and default (rhu-path default))
					 (file-name-directory
					   (rhu-path default)))
				     ;; Assume default should be relative to
				     ;; current buffer.
				     default-directory))
			       (expanded (expand-file-name path default-dir)))
			  (setq path expanded))))))
	(make-rgr-html-url :host host
			   :protocol protocol
			   :path path
			   :searchpart searchpart
			   ;; rfc1808.p10:  "Fragment identifiers are only
			   ;; inherited from the base URL when the entire
			   ;; embedded URL is empty."  -- rgr, 23-Sep-97.
			   :fragment (if (and default
					      (rgr-html-empty-url-p url))
					 (rhu-fragment default)
					 (rhu-fragment url))))))

(defun rgr-html-url-namestring (url &optional default)
  ;; This takes advantage of the fact that rgr-html-url structures are lists in
  ;; order to also provide "enough-namestring" functionality.
  (let ((host (if (and default (equal (rhu-host url) (rhu-host default)))
		  nil
		  (rhu-host url)))
	(protocol
	  (if (and default (equal (rhu-protocol url) (rhu-protocol default)))
	      nil
	      (rhu-protocol url)))
	;; this includes the / after host/proto.
	(path (cond ((null default)
		      (rhu-path url))
		    ((or (null (rhu-path url))
			 (equal (rhu-path url) (rhu-path default)))
		      nil)
		    ((null (rhu-path default))
		      (rhu-path url))
		    ;; both are stringp.
		    ((equal (file-name-directory (rhu-path url))
			    (file-name-directory (rhu-path default)))
		      (file-name-nondirectory (rhu-path url)))
		    (t
		      (rhu-path url)))))
    (concat (if host "http://")
	    host
	    (if protocol ":")
	    protocol
	    path
	    (if (rhu-searchpart url) "?")
	    (rhu-searchpart url)
	    (if (rhu-fragment url) "#")
	    (rhu-fragment url))))

(defun rgr-html-local-url-p (url)
  ;; URL may be a string, or a merged URL structure.  Returns the complete file
  ;; name if true.  Also handles finding out which of index.s?html? is meant by
  ;; a trailing slash.  [Not that this is ideal.  -- rgr, 15-Jun-00.]
  (let* ((parsed (cond ((stringp url) (rgr-html-merge-url url))
		       ((consp url) url)
		       (t (error "\"%S\" is not a URL." url))))
	 (access-path (rgr-html-local-server-p (rhu-host parsed)
					       (rhu-protocol parsed))))
    (if access-path
	(let* ((path (rhu-path parsed))
	       (server-root-dir
		 (if (consp (rhsap-root-directory access-path))
		     (car (rhsap-root-directory access-path))
		     (rhsap-root-directory access-path)))
	       (file (cond ((file-readable-p path)
			     ;; [***kludge***: this attempts to work for
			     ;; something that's not installed in the server
			     ;; directories.  not that it's clear how to
			     ;; reference these . . .  -- rgr, 25-Aug-97.]
			     path)
			   ((= (aref path 0) ?/)
			     ;; [this can't use expand-file-name to knit the
			     ;; pieces together, but that no longer works for
			     ;; "root" names.  we just hope there is no funny
			     ;; ../ stuff in there.  -- rgr, 19-Jan-98.]
			     (concat server-root-dir path))
			   (t
			     ;; [it probably should be an error to go ../ into
			     ;; the root name.  -- rgr, 19-Jan-98.]
			     (expand-file-name path server-root-dir)))))
	  (if (file-directory-p file)
	      (let ((tail '("index.htm" "index.html" "index.shtml"))
		    (result nil))
		(while tail
		  (let ((new-file (expand-file-name (car tail) file)))
		    (if (file-readable-p new-file)
			(setq result new-file
			      tail nil)
			(setq tail (cdr tail)))))
		;; result might still be nil . . .  -- rgr, 15-Jun-00.
		result)
	      file)))))

(defun rgr-html-same-directory-p (file-name root-directory)
  ;; Returns the name of the matching root directory, or nil.
  (cond ((stringp root-directory)
	  (let ((root-len (length root-directory)))
	    (and (> (length file-name) root-len)
		 (string-equal (substring file-name 0 root-len) root-directory)
		 root-directory)))
	((listp root-directory)
	  (let ((result nil) (tail root-directory))
	    (while tail
	      (if (setq result (rgr-html-same-directory-p file-name (car tail)))
		  (setq tail nil)
		  (setq tail (cdr tail))))
	    result))
	(t
	  (error "malformed root directory %S." root-directory))))

(defun rgr-html-file-server (file-name)
  ;; Find the server corresponding to this file, or nil if no entry exists for
  ;; it in the rgr-html-local-server-access-paths list.  -- rgr, 6-Apr-00.
  (let ((result nil) (tail rgr-html-local-server-access-paths))
    (while tail
      (let ((server (car tail)))
	(if (rgr-html-same-directory-p file-name
				       (rhsap-root-directory server))
	    (setq result server
		  tail nil)
	    (setq tail (cdr tail)))))
    result))

(defun rgr-html-server-file-url (server file-name)
  ;; Given a server and a file name on that server, return the (parsed) url.
  ;; Signals an error if file-name is not on server (but see rgr-html-file-url,
  ;; which takes just a file name).
  (let* ((root-directory
	   (or (rgr-html-same-directory-p file-name
					  (rhsap-root-directory server))
	       (error "%S is not on %S." file-name server))) 
	 (root-len (length root-directory)))
    (make-rgr-html-url :host (rhsap-server-name server)
		       :protocol (rhsap-protocol server)
		       :path (substring file-name root-len))))

(defun rgr-html-file-url (file-name)
  ;; Given a complete (merged) file name for a file on a "local" server, return
  ;; a complete (merged) parsed URL structure.  Signals an error if not local
  ;; (which shouldn't happen for local files, except that it might not be in the
  ;; htdocs directory . . .)  [this is a kludge; we should just make a
  ;; "file:..." URL in this case.  if netscape can deal with this, we ought to
  ;; as well.  -- rgr, 3-Feb-99.]  [inverse of the rgr-html-local-server-p
  ;; function.  -- rgr, 23-Sep-97.]
  (or file-name
      ;; html buffers should always have an associated file, but no need to die
      ;; if that is not the case.  -- rgr, 30-Jan-99.
      (error "Not a file buffer; can't determine default URL."))
  (let* ((server (rgr-html-file-server file-name))
	 (result
	   (and server (rgr-html-server-file-url server file-name))))
    (or result
	;; [***kludge***: should always be able to make a "file:" URL for this.
	;; but none of the code expects this yet.  -- rgr, 3-Feb-99.]
	(error "Can't build a URL for \"%s\"." file-name))))

;;;; Local anchor database

(defvar rgr-html-local-anchors (make-vector 503 0)
  "Symbol table for fragment (aka tag) to rgr-html-anchor structure mapping.
The value of each symbol is a *list* of rgr-html-anchor structures, since a
given tag can be defined once in each file.")

;; Really, this should be an alist of (full-file-name . url) [or maybe url-path]
;; so we can reliably flush these in the absence of the buffer.  -- rgr,
;; 27-Aug-97.
(defvar rgr-html-local-pages nil
  "List of files in the rgr-html-local-anchors table.")

(defun rgr-html-find-local-anchor-no-update (path tag)
  (let* (;; We assume these are case-insensitive.
	 (tag (downcase tag))
	 (symbol (intern tag rgr-html-local-anchors))
	 (result nil))
    (or (boundp symbol)
	(set symbol nil))
    (let ((tail (symbol-value symbol)))
      (while tail
	(let ((entry (car tail)))
	  ;; NB: string-equal is case-sensitive in emacs lisp.
	  (if (and (string-equal tag (rha-name entry))
		   (equal path (rhu-path (rha-url entry))))
	      (setq result entry tail nil)
	      (setq tail (cdr tail))))))
    result))

(defun rgr-html-flush-buffer-anchors-internal (path &optional dont-delete-p)
  ;; Removes all local tag definitions and their markers for the buffer implied
  ;; by path, but doesn't touch the included-files database.  If the optional
  ;; dont-delete-p is true, then leave the entries but flush the markers.
  (mapatoms (function (lambda (entry-symbol)
	      (let* ((entries (and (boundp entry-symbol)
				   (symbol-value entry-symbol)))
		     (tail entries))
		(while tail
		  (let* ((entry (car tail))
			 (marker (rha-where entry)))
		    (cond ((equal path (rhu-path (rha-url entry)))
			    (if (markerp marker)
				(set-marker marker nil))
			    (psa-setf (rha-where entry) nil)
			    (or dont-delete-p
				(set entry-symbol (delete entry entries))))))
		  (setq tail (cdr tail))))))
	    rgr-html-local-anchors))

(defun rgr-html-kill-buffer-flush-buffer-markers (&optional buffer delete-p)
  ;; Hook function for when we want to remember the tags in for the given buffer
  ;; (defaults to the current buffer), but need to nuke all markers to it, with
  ;; an extra delete-p arg in case we want to flush the tag entries, too.
  ;; Buffer can be the symbol 'all' to affect all buffers.  [could replace
  ;; rgr-html-flush-buffer-anchors-internal with this . . .  -- rgr, 27-Aug-97.]
  ;; [***bug***: this requires the buffer's marker data to be intact for the
  ;; delete-p option to work.  -- rgr, 27-Aug-97.]
  (or buffer
      (setq buffer (current-buffer)))
  (cond ((or (eq buffer 'all)
	     (member (buffer-file-name buffer) rgr-html-local-pages))
	  (mapatoms (function (lambda (entry-symbol)
		      (let* ((entries (and (boundp entry-symbol)
					   (symbol-value entry-symbol)))
			     (tail entries))
			(while tail
			  (let* ((entry (car tail))
				 (marker (rha-where entry)))
			    (cond ((and (markerp marker)
					(or (eq buffer 'all)
					    (eq (marker-buffer marker) buffer)
					    ;; GC uncleaned refs.
					    (null (marker-buffer marker))))
				    (set-marker marker nil)
				    (psa-setf (rha-where entry) nil)
				    (and delete-p
					 (setq entries
					       (delete entry entries))))))
			  (setq tail (cdr tail)))
			(and delete-p
			     (set entry-symbol entries)))))
		    rgr-html-local-anchors)
	  ;; Update the list of known files.
	  (cond ((not delete-p))
		((bufferp buffer)
		  (setq rgr-html-local-pages (delete (buffer-file-name buffer)
						     rgr-html-local-pages)))
		((eq buffer 'all)
		  (setq rgr-html-local-pages nil))))))

;;;###autoload
(defun rgr-html-flush-file-anchors (file-name)
  "Forget all anchor definitions from the database for the given file."
  (interactive "FFlush anchor definitions for file: ")
  (let* ((url (rgr-html-file-url file-name))
	 (namestring (rgr-html-url-namestring url)))
    (cond ((not (member file-name rgr-html-local-pages))
	    (message "%s is not cached." namestring))
	  (t
	    (message "Flushing %s local anchors." namestring)))
    (rgr-html-flush-buffer-anchors-internal (rhu-path url))
    (setq rgr-html-local-pages (delete file-name rgr-html-local-pages))))

(defun rgr-html-flush-all-anchors ()
  "Flush the database altogether."
  (interactive)
  (and (y-or-n-p "OK to forget all cached anchor information? ")
       (rgr-html-kill-buffer-flush-buffer-markers 'all t)))

;;;###autoload
(defun rgr-html-update-buffer-anchors (&optional silent)
  ;; Force update of local tag definitions on the current buffer.
  (interactive)
  (let* ((current-page-url (rgr-html-file-url buffer-file-name))
	 (namestring (rgr-html-url-namestring current-page-url))
	 (path (rhu-path current-page-url))
	 (message-prefix nil) (n-anchors 0))
    (cond ((member buffer-file-name rgr-html-local-pages)
	    ;; Redoing a page.
	    (rgr-html-flush-buffer-anchors-internal path)
	    (or silent
		(setq message-prefix
		      (concat "Updating " namestring " in database"))))
	  (t
	    ;; Adding a page.
	    (setq rgr-html-local-pages
		  (cons buffer-file-name rgr-html-local-pages))
	    ;; Make sure we don't leave dangling markers.
	    (make-local-variable 'kill-buffer-hook)
	    (add-hook 'kill-buffer-hook
		      'rgr-html-kill-buffer-flush-buffer-markers)
	    (add-hook 'local-write-file-hooks
		      'rgr-html-save-buffer-update-anchors)
	    (or silent
		(setq message-prefix
		      (concat "Adding " namestring " to database")))))
    (or silent
	(message "%s..." message-prefix))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "<a[ \t\n]" nil t)
	(let* (;; (tag (match-string 1))
	       (attributes (rgr-html-parse-tag-attributes))
	       (tag (cdr (assoc 'name attributes))))
	  (if tag
	      (let* (;; We assume these are case-insensitive.
		     (tag (downcase tag))
		     (entry-symbol (intern tag rgr-html-local-anchors))
		     (entry (rgr-html-find-local-anchor-no-update path tag))
		     (url (let ((copy (append current-page-url nil)))
			    (psa-setf (rhu-fragment copy) tag)
			    copy)))
		(cond ((null entry)
			;; Make sure we know about the definition.
			(set entry-symbol
			     (cons (make-rgr-html-anchor
				     :name tag
				     :url url
				     :where (set-marker (make-marker)
							(match-beginning 0)))
				   (symbol-value entry-symbol)))
			(setq n-anchors (1+ n-anchors)))
		      ((not silent)
			(message "Duplicate definition of '%s' -- ignoring."
				 tag)
			(sit-for 1))))))))
    (or silent
	(message "%s...done, %d anchors defined." message-prefix n-anchors))))

;;;###autoload
(defun rgr-html-update-all-buffer-anchors ()
  "Update the anchor database for all (HTML) buffers."
  (interactive)
  (let ((tail (buffer-list)))
    (while tail
      (save-excursion
	(set-buffer (car tail))
	(if (memq major-mode '(html-helper-mode html-mode))
	    (rgr-html-update-buffer-anchors)))
      (setq tail (cdr tail)))
    (sit-for 1)
    (message "Done.")))

(defun rgr-html-save-buffer-update-anchors ()
  ;; local-write-file-hooks hook function -- if the file is still present in the
  ;; database, make sure it's up to date.
  (if (member buffer-file-name rgr-html-local-pages)
      ;; [maybe this shouldn't be silent?  -- rgr, 27-Aug-97.]
      (rgr-html-update-buffer-anchors t))
  ;; This must return nil, or the file doesn't get written.
  nil)

(defun rgr-html-maybe-update-file-anchors (file-name)
  ;; If the given file exists and is not in the local anchor database, update
  ;; it; if not, give up without bothering the user.  This means making it a
  ;; buffer if it has not been read in yet.
  (or (member file-name rgr-html-local-pages)
      (let ((buffer (get-file-buffer file-name)))
	(if (and (null buffer)
		 (file-readable-p file-name))
	    (setq buffer (find-file-noselect file-name)))
	(cond ((null buffer) nil)
	      ((member (buffer-file-name buffer) rgr-html-local-pages)
		;; oops; get-file-buffer has been confused by symbolic links,
		;; but find-file-noselect has straightened things out (printing
		;; a warning along the way, unfortunately).  remember the
		;; original file name as an alias for something we already know.
		;; [kludge:  yes, I know.  -- rgr, 28-Nov-00.]
	        (setq rgr-html-local-pages
		      (cons file-name rgr-html-local-pages)))
	      (t
	        ;; a genuinely new file.
	        (save-excursion
		  (set-buffer buffer)
		  (rgr-html-update-buffer-anchors)))))))

(defun rgr-html-find-local-anchor (url)
  ;; Given a parsed url, return the rgr-html-anchor structure for it if it is
  ;; local and uses an explicit tag, the filename if not, or nil if not local or
  ;; not defined.
  (let ((local-file-name (rgr-html-local-url-p url))
	(tag (rhu-fragment url)))
    (cond ((not local-file-name)
	    ;; Can't do much about nonlocal guys.
	    nil)
	  ((null tag)
	    ;; Reference to the whole page; just return the file name.
	    local-file-name)
	  (t
	    ;; Reference to a tag on a specific page.
	    (let ((path (rhu-path url)))
	      (if (and (string-match (regexp-quote path) local-file-name)
		       (< (match-end 0) (length local-file-name)))
		  ;; path is a prefix of the actual path, e.g. /psa/ standing
		  ;; for /psa/index.htm, so use the complete file name version
		  ;; found by the rgr-html-local-url-p fn.  -- rgr, 7-Nov-00.
		  (setq path (substring local-file-name (match-beginning 0))))
	      (rgr-html-maybe-update-file-anchors local-file-name)
	      (rgr-html-find-local-anchor-no-update path tag))))))

;;;; URL validation commands & their support.

(defvar rgr-html-all-undefined-urls nil
  "Alist of (buffer current-page-url . refs), where each refs entry is
an alist of (name . points).")
(defvar rgr-html-all-unchecked-urls nil
  "List of strings.")
(defvar rgr-html-output-buffer-name "*html references*"
  "Name of buffer into which user messages should go.")

(defun rgr-pluralize (quantity &optional if-singular if-plural)
  (if (if (listp quantity)
	  (and quantity (null (cdr quantity)))
	  (eq quantity 1))
      (or if-singular "")
      (or if-plural "s")))

(defun rgr-html-replace-word (word url-start url-end)
  ;; grinder for rgr-html-maybe-fix-url-p -- split out to make it easier to get
  ;; fancy.  must return the word, though.
  (save-excursion
    (delete-region url-start url-end)
    (goto-char url-start)
    (insert word))
  word)

(defun rgr-html-maybe-fix-url-p (url url-string url-start url-end
				     current-page-url)
  ;; Try to ask the user for the right url.  [***bug***: this uses
  ;; ispell-command-loop, which has approximately the right interface, but can
  ;; bugger up the dictionary if the user is not careful.  -- rgr, 25-Aug-97.]
  (let* ((entry-symbol
	   (intern (downcase (rhu-fragment url)) rgr-html-local-anchors))
	 (alternatives
	   (mapcar (function (lambda (anchor)
		     (rgr-html-url-namestring (rha-url anchor)
					      current-page-url)))
		   (and (boundp entry-symbol)
			(symbol-value entry-symbol))))
	 (replace
	   (cond ((null alternatives) nil)
		 ((null (cdr alternatives))
		   ;; Only one choice -- avoid ispell UI.
		   (let ((message (message "Replace \"%s\" with \"%s\"? "
					   url-string (car alternatives)))
			 (response (read-event)))
		     (while (not (member response '(?\  ?y ?Y ?n ?N ?A ?0)))
		       (beep)
		       (message "'y' to change, 'n' to leave, 'A' to accept.")
		       (sit-for 2)
		       (message "%s" message)
		       (setq response (read-event)))
		     (cond ((member response '(?\  ?y ?Y ?0))
			     (car alternatives))
			   ((eq response ?A)
			     ;; Compatible with ispell-command-loop return, only
			     ;; way we can get a "proceed" out of it.
			     0)
			   (t nil))))
		 (t
		   (require 'ispell)
		   '(message "String %S start %s end %s"
			    url-string url-start url-end)
		   '(sit-for 2)
		   (save-window-excursion
		     (ispell-command-loop alternatives nil
					  url-string url-start url-end))))))
    (cond ((null replace)
	    ;; Nothing possible, or nothing requested.
	    nil)
	  ((equal 0 replace)
	    (rgr-html-replace-word (car alternatives) url-start url-end))
	  (replace
	    (rgr-html-replace-word (if (atom replace) replace (car replace))
				   url-start url-end)
	    t))))

(defun rgr-html-print-undefined-url (buffer url points current-page-url)
  ;; Show an undefined URL with a set of reference points to the user, printing
  ;; any alternatives for a tag reference, and generating the points and the
  ;; messages in a syntax that compilation-mode will understand.
  (save-excursion
    (set-buffer buffer)
    (let* ((points (reverse points))
	   (prefix (format "%s:%d"
			   (buffer-name buffer)
			   (count-lines (point-min) (car points)))))
      ;; "Undefined URL" message.
      (princ (format "%s: Undefined URL \"%s\" (%d ref%s)\n"
		     prefix
		     (if (stringp url)
			 ;; [***bug***: don't know why this is a string, but
			 ;; don't die now.  -- rgr, 22-Feb-99.]
			 url
			 (rgr-html-url-namestring url current-page-url))
		     (length points) (rgr-pluralize points)))
      ;; Offer alternatives, if possible.
      (let* ((entry-symbol (if (stringp url)
			       nil
			       (intern (downcase (rhu-fragment url))
				       rgr-html-local-anchors)))
	     (alternatives
	      (mapcar (function (lambda (anchor)
			(rgr-html-url-namestring (rha-url anchor)
						 current-page-url)))
		      (and (boundp entry-symbol)
			   (symbol-value entry-symbol)))))
	(cond ((null alternatives))
	      ((null (cdr alternatives))
		;; only one alternative.
		(princ (format "%s:   An alternative is \"%s\"\n"
			       prefix (car alternatives))))
	      (alternatives
		(princ prefix)
		(princ (format ":   %d alternatives exist:\n"
			       (length alternatives)))
		(mapcar (function (lambda (anchor)
			  (princ prefix)
			  (princ (format ":      \"%s\"\n" anchor))))
			alternatives))))
      ;; And print the points.
      (while points
	(princ (format "%s:%d:"
		       (buffer-name buffer)
		       (count-lines (point-min) (car points))))
	(goto-char (car points))
	(beginning-of-line)
	(princ (buffer-substring (point)
				 (progn (forward-line)
					(point))))
	(setq points (cdr points))))))

(defun rgr-html-print-string-list (title list)
  (cond (list
	  (princ title)
	  (princ "\n\n")
	  (mapcar (function (lambda (url)
		    (princ (format "   %s\n" url))))
		  list)
	  (princ "\n"))))

(defun rgr-html-unref-entry-buffer-name-lessp (buffer-entry-1 buffer-entry-2)
  (string-lessp (buffer-name (car buffer-entry-1))
		(buffer-name (car buffer-entry-2))))

(defun rgr-html-show-undefined-hrefs-internal
       (all-undefined unchecked &optional buffer-name unreferenced-files)
  ;; Helper for rgr-html-check-buffer-hrefs and rgr-html-check-directory-hrefs;
  ;; generates the output buffer from the data structures generated by
  ;; rgr-html-check-buffer-hrefs-internal.
  (let ((n-undefined-urls 0)
	(buffer-name (or buffer-name rgr-html-output-buffer-name)))
    (with-output-to-temp-buffer buffer-name
      (let ((tail (sort (append all-undefined nil)
			(function rgr-html-unref-entry-buffer-name-lessp))))
	(save-excursion
	  (while tail
	    (let* ((entry (car tail))
		   (buffer (car entry)) (current-page-url (car (cdr entry)))
		   (undefined (cdr (cdr entry))))
	      (princ (format "Undefined references within %s:\n\n" buffer))
	      (mapcar (function (lambda (url-dot-points)
			(rgr-html-print-undefined-url
			  buffer (car url-dot-points) (cdr url-dot-points)
			  current-page-url)))
		      undefined)
	      (setq n-undefined-urls
		    (+ n-undefined-urls (length undefined)))
	      (princ "\n"))
	    (setq tail (cdr tail)))))
      (rgr-html-print-string-list "Unchecked references" unchecked)
      (rgr-html-print-string-list "Unreferenced files" unreferenced-files)
      (princ "Anchors are known from the following file buffers:\n\n")
      (mapcar (function (lambda (file-name)
		(princ (format "   %s\n" file-name))))
	      rgr-html-local-pages))
    ;; Set the temp buffer up for compilation-mode
    (save-excursion
      (set-buffer buffer-name)
      ;; [should this be compilation-minor-mode instead?  -- rgr, 30-Jan-99.]
      (compilation-mode))
    ;; Generate user message about total number of errors.
    (message "%d undefined reference%s%s and %d unchecked reference%s."
	     n-undefined-urls (rgr-pluralize n-undefined-urls)
	     (if (cdr all-undefined)
		 ;; More than one page; say so.
		 (format " on %d page%s"
			 (length all-undefined)
			 (rgr-pluralize all-undefined))
		 "")
	     (length unchecked) (rgr-pluralize unchecked))))

(defun rgr-html-check-buffer-hrefs-internal (suggest-fix-p)
  ;; Check hrefs (and img src tags) in the current buffer.
  (rgr-html-maybe-update-file-anchors buffer-file-name)
  (let ((start (point))
	(referenced-files nil)	;; list of referenced local HTML files
	(current-page-url (rgr-html-file-url buffer-file-name))
	(ispell-quit nil)	;; may be set by ispell-command-loop to exit.
	(proceed nil)	;; database of correct-without-asking pairs
	(undef-alist nil))
    (goto-char (point-min))
    (while (and (not ispell-quit)
		(re-search-forward rgr-html-href-regexp nil t))
      (let* ((url-string (rgr-html-href-target))
	     (url-start (match-beginning 3)) (url-end (match-end 3))
	     (url (rgr-html-merge-url url-string current-page-url))
	     (anchor nil) (undefined-p nil) (fix nil) (new nil))
	;; Classify the reference.
	(cond ((null url)
		;; probably "mailto:" or something.
		(or (member url-string rgr-html-all-unchecked-urls)
		    ;; [quick hack.  -- rgr, 23-Sep-97.]
		    (and (string-match "^mailto:" url-string)
			 (equal (substring url-string (match-end 0))
				user-mail-address))
		    (setq rgr-html-all-unchecked-urls
			  (cons url-string rgr-html-all-unchecked-urls))))
	      ((null (setq anchor (rgr-html-find-local-anchor url)))
		;; Not defined (must ensure that it's local, though).
		(if (rgr-html-local-url-p url)
		    (setq undefined-p url)))
	      ((stringp anchor)
		;; Reference to the whole page.
		(cond ((not (file-readable-p anchor))
		        (setq undefined-p url-string))
		      ;; [don't filter out non-html files here; we want to be
		      ;; able to detected unused gifs, for example.
		      ((and ;; (string-match "\\.s?html?$" anchor)
			    (not (member anchor referenced-files)))
		        (setq referenced-files
			      (cons anchor referenced-files)))))
	      (t
	        (let ((file-name (rgr-html-anchor-file-name anchor)))
		  ;; Reference to a defined anchor -- we're OK here.
		  ;; (message "Got anchor %S." anchor)
		  ;; (sit-for 1)
		  (and file-name
		       (not (member file-name referenced-files))
		       (setq referenced-files
			     (cons file-name referenced-files))))))
	;; Decide what to do if undefined.
	(cond ((null undefined-p))
	      ((setq fix (assoc url-string proceed))
		(rgr-html-replace-word (cdr fix) url-start url-end))
	      ((and suggest-fix-p
		    ;; [***bug***: can't offer to fix broken whole-page
		    ;; references.  -- rgr, 25-Aug-97.]
		    (not (stringp undefined-p))
		    (setq new (rgr-html-maybe-fix-url-p
				url url-string url-start
				url-end current-page-url)))
		;; A string means replace all throughout.
		(if (stringp new)
		    (setq proceed (cons (cons url-string new) proceed))))
	      (t
		;; Record the problem for later playback.
		(let ((entry (assoc undefined-p undef-alist)))
		  (or entry
		      (setq entry (cons undefined-p nil)
			    undef-alist (cons entry undef-alist)))
		  (setcdr entry (cons (point) (cdr entry))))))))
    (goto-char start)
    ;; (message "%s refs local files %S." (current-buffer) referenced-files)
    ;; (sit-for 1)
    (and undef-alist
	 ;; Add an entry for this buffer in rgr-html-all-undefined-urls
	 (setq rgr-html-all-undefined-urls
	       (cons (cons (current-buffer)
			   (cons current-page-url undef-alist))
		     rgr-html-all-undefined-urls)))
    referenced-files))

;;;###autoload
(defun rgr-html-check-buffer-hrefs (&optional suggest-fix-p)
  "Check the rest of the current buffer for references to undefined
anchors.  With a numeric argument, offers to replace an undefined
reference to one in another file (with caveats about the extensiveness
of the tag database).  Can't handle offsite references."
  (interactive "P")
  (let ((rgr-html-all-undefined-urls nil)
	(rgr-html-all-unchecked-urls nil))
    (rgr-html-check-buffer-hrefs-internal suggest-fix-p)
    (cond (rgr-html-all-undefined-urls
	    ;; normal warn-about-everything case.
	    (rgr-html-show-undefined-hrefs-internal
	      rgr-html-all-undefined-urls
	      rgr-html-all-unchecked-urls))
	  (rgr-html-all-unchecked-urls
	    ;; Just print the message and generate (but don't show) the buffer
	    ;; with the list of unchecked references.  This so as not to bother
	    ;; the user with something that is probably only interesting the
	    ;; first time.  -- rgr, 4-Sep-97.
	    (save-window-excursion
	      (rgr-html-show-undefined-hrefs-internal
		rgr-html-all-undefined-urls
		rgr-html-all-unchecked-urls)))
	  (t
	    (and (get-buffer rgr-html-output-buffer-name)
		 (kill-buffer rgr-html-output-buffer-name))
	    (message "No undefined local references.")))))

;;;###autoload
(defun rgr-html-fix-buffer-hrefs ()
  "Fix references to undefined anchors in the rest of the current buffer.
Offers to replace an undefined reference to one in another file (with
caveats about the extensiveness of the tag database).  Can't handle
offsite references."
  (interactive)
  (rgr-html-check-buffer-hrefs t))

;;;###autoload
(defun rgr-html-check-directory-hrefs ()
  "Check references to undefined anchors in the current buffer, and everything
in the same directory that is reachable from the current buffer."
  (interactive)
  (save-excursion
    (let* ((rgr-html-all-undefined-urls nil)
	   (rgr-html-all-unchecked-urls nil)
	   (buffers-done nil)
	   (buffers-to-do (list (current-buffer)))
	   (other-directory-files nil);; list of non-html files in this dir
	   (unreferenced-directory-files nil)
	   (local-server (rgr-html-file-server buffer-file-name))
	   (local-directory
	     (file-name-directory
	       (if local-server
		   (rhu-path (rgr-html-server-file-url local-server
						       buffer-file-name))
		   buffer-file-name))))
      (while buffers-to-do
	(set-buffer (car buffers-to-do))
	(setq buffers-to-do (cdr buffers-to-do))
	(setq buffers-done (cons (current-buffer) buffers-done))
	(message "Checking references in %s..." (buffer-name))
	(let ((files (rgr-html-check-buffer-hrefs-internal nil)))
	  ;; All checked; now see if this guy references anybody in this buffer
	  ;; we don't know about yet.
	  (while files
	    (let* ((file (car files))
		   (server (rgr-html-file-server file)))
	      ;; First check to see that we are on the same directory of the
	      ;; same server.  [this is way too complicated; really not work the
	      ;; headache to deal with directory symlinks this way.  -- rgr,
	      ;; 6-Apr-00.]
	      (cond ((or (not (eq server local-server))
			 (not (equal local-directory
				     (file-name-directory
				       (if local-server
					   (rhu-path (rgr-html-server-file-url
						       server
						       file))
					   file)))))
		      ;; [debugging.  -- rgr, 6-Apr-00.]
		      '(message "%s is not in directory." file))
		    ;; [checking the file extension is something of a kludge.
		    ;; for one thing, somebody may have put other extensions on
		    ;; auto-mode-alist; for another, the file itself may use a
		    ;; mode that implies html, regardless of extension.  so we'd
		    ;; be better off reading in the file & checking the buffer
		    ;; mode, except then i'd have to deal with cleaning up
		    ;; random gifs and pdf files after determining that they
		    ;; weren't html.  -- rgr, 3-Feb-99.]
		    ((string-match "\\.s?html?$" file)
		      ;; an html file; make sure we check it (or have checked).
		      (let ((buffer (find-file-noselect file)))
			(or (member buffer buffers-done)
			    (member buffer buffers-to-do)
			    (setq buffers-to-do (cons buffer buffers-to-do)))))
		    (t
		      ;; other random file type; note it as referenced.
		      (or (member file other-directory-files)
			  (setq other-directory-files
				(cons file other-directory-files))))))
	    (setq files (cdr files)))))
      ;; Now look for files in this directory that aren't referenced.
      (let ((dir-files (directory-files default-directory t "^[^.][^~#]+$" t)))
	(while dir-files
	  (let ((file (car dir-files)))
	    (or (member file other-directory-files)
		(file-directory-p file)		;; also eliminates . & ..
		(memq (get-file-buffer file) buffers-done)
		(setq unreferenced-directory-files
		      (cons file unreferenced-directory-files))))
	  (setq dir-files (cdr dir-files))))
      ;; [this message gets lost, but it's in the *Messages* buffer if you need
      ;; to look at it.  -- rgr, 30-Jan-99.]
      (message "Done; checked %d buffers." (length buffers-done))
      ;; Finished all connected pages in this directory; show the results.
      (rgr-html-show-undefined-hrefs-internal
	rgr-html-all-undefined-urls
	rgr-html-all-unchecked-urls
	;; Give this a unique name so later rgr-html-fix-buffer-hrefs usage
	;; doesn't flush it.
	(concat "*undefs in " default-directory "*")
	unreferenced-directory-files))))

(provide 'rgr-html-tags)

(run-hooks 'rgr-html-tags-load-hook)

;;;; Debugging support.

(defun rgr-html-dump-anchor-database ()
  (interactive)
  (with-output-to-temp-buffer "*anchor database*"
    (mapatoms (function (lambda (entry-symbol)
		(let* ((entries (and (boundp entry-symbol)
				     (symbol-value entry-symbol)))
		       (tail entries))
		  (princ (format "%s:\n" entry-symbol))
		  (while tail
		    (let ((entry (car tail)))
		      (princ (format "  %S\n" entry)))
		    (setq tail (cdr tail))))))
	      rgr-html-local-anchors)))
