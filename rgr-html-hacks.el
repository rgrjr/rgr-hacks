;;;*****************************************************************************
;;;
;;;;   html-helper-mode extension hacks.
;;;
;;;    To get this to compile without errors or warnings, do
;;;
;;;	(mapcar 'require '(html-helper-mode))
;;;
;;; beforehand.
;;;
;;;    Tags in tag lists were generated by looking at the
;;; http://werbach.com/barebones/barebone_html.html document.
;;;
;;;    Modification history:
;;;
;;; created.  -- rgr, 1-Feb-96.
;;; new rgr-html-fill-paragraph fn (the only thing working).  -- rgr, 22-Feb-96.
;;; rgr-html-fill-paragraph: save-excursion, fix minor bug.  -- rgr, 8-Mar-96.
;;; rgr-html-forward-paragraph, use in ..-fill-paragraph.  -- rgr, 11-Mar-96.
;;; rgr-html-fill-paragraph: justify-p, add interactive.  -- rgr, 13-Mar-96.
;;; rgr-html-fill-paragraph: don't include most tags as part of the
;;;	paragraph.  -- rgr, 14-Mar-96.
;;; rgr-html-fill-paragraph: fix (point) bone-headedness, last-location hack in
;;;	rgr-html-collect-tag-data, check-tag menu item.  -- rgr, 19-Mar-96.
;;; rgr-html-collect-tag-data: support <a name/href> diff.  -- rgr, 17-Jun-96.
;;; rgr-collect-headings: starting TOC generator.  -- rgr, 13-Jul-96.
;;; rgr-html-make-toc: new TOC command.  -- rgr, 15-Jul-96.
;;; rgr-html-make-toc: fix point bug when remaking old TOC.  -- rgr, 16-Jul-96.
;;; rgr-html-make-toc: autoload, add documentation.  -- rgr, 20-Jul-96.
;;; rgr-html-make-toc: don't move . when asking to insert.  -- rgr, 20-Jul-96.
;;; rgr-html-collect-tag-data: fixing text property bugs.  -- rgr, 2-Aug-96.
;;; rgr-html-paragraph-start-tags: add dd/dt tags.  -- rgr, 15-May-97.
;;; fix minor bug in menu installation.  -- rgr, 26-Jul-97.
;;; rgr-html-install-menu-items: new fn, tag checking cmds.  -- rgr, 26-Aug-97.
;;; rgr-html-install-menu-items: made smarter.  -- rgr, 27-Aug-97.
;;; rgr-html-helper-mode-hook: move this here.  -- rgr, 14-Oct-97.
;;; rgr-html-forward-markup: new commands, related support.  -- rgr, 4-Dec-97.
;;; rgr-html-matched-tag-name search, a-name is also a last-a-tag in
;;;	rgr-html-forward-markup.  -- rgr, 29-Jan-98.
;;; rgr-html-execute-do: hack "&gt;", "&lt;", and "\^J".  -- rgr, 8-Feb-98.
;;; rgr-html-ul-to-dl: new, plus support.  -- rgr, 22-Feb-98.
;;; rgr-html-indent-markup: new (but uses buggy indent cmd).  -- rgr, 12-Mar-98.
;;; rgr-html-define-commands: M-[ and M-] -> M-{ and M-}.  -- rgr, 21-Mar-98.
;;; rgr-html-kill-markup: new.  -- rgr, 21-Mar-98.
;;; split up, fix rgr-html-move-one-paragraph bobp bug.  -- rgr, 23-Mar-98.
;;; rgr-html-non-paragraph-tags: some HTML 3.2 updates.  -- rgr, 24-Mar-98.
;;; rgr-html-parse-tag-attributes: correct syntax.  -- rgr, 30-Mar-98.
;;; rgr-html-parse-tag-attributes: fix bugs.  -- rgr, 8-Apr-98.
;;; rgr-collect-headings: flush rgr-anchor-definition-re in favor of parsing
;;;	the attributes.  -- rgr, 16-Apr-98.
;;; rgr-html-parse-tag-attributes: work around apparent bug in emacs 19.30
;;;	regexp (not skip-chars) character classes.  -- rgr, 25-Apr-98.
;;; rgr-collect-headings: ignore <hr> and <p> when looking for an anchor.
;;;	-- rgr, 19-Nov-98.
;;; rgr-html-define-commands: rgr-html-check-directory-hrefs.  -- rgr, 2-Feb-99.
;;; rgr-html-fix-regexps: new; fixes tag indentation.  -- rgr, 26-Jul-99.
;;; update rgr-html-fix-regexps and rgr-html-define-commands for html-helper-mode
;;;	version 2.0 (at bootcamp).  -- rgr, 11-Aug-99.
;;; rgr-html-fix-regexps: also update new-buffer template.  -- rgr, 15-Sep-99.
;;; rgr-html-fix-regexps: add <P> before <HR>.  -- rgr, 27-Sep-99.
;;; rgr-html-make-documentation-stub: new (unfinished).  -- rgr, 4-Oct-99.
;;; rgr-html-close-markup: new hack!  -- rgr, 11-Oct-99.
;;; rgr-html-close-markup: now indents.  -- rgr, 8-Nov-99.
;;; rgr-html-close-markup: now uses rgr-html-tags-needing-newline to decide
;;;	when to add a newline.  -- rgr, 9-Nov-99.
;;; rgr-html-forward-li: improve documentation.  -- rgr, 10-Nov-99.
;;; rgr-html-helper-mode-hook: tweak auto fill.  -- rgr, 15-Dec-99.
;;; rgr-html-do-auto-fill: fix bug in indenting after <li>.  -- rgr, 13-Jan-00.
;;; rgr-html-define-commands: html-helper-address-string.  -- rgr, 24-Jan-00.
;;; rgr-html-close-markup: made more sophisticated about nl.  -- rgr, 31-Mar-00.
;;; rgr-html-insert-or-skip-newline: flush debug message.  -- rgr, 10-May-00.
;;; rgr-html-make-documentation-stub: minor updating.  -- rgr, 19-Feb-01.
;;; new TOC heuristic, don't number if already numbered.  -- rgr, 23-Apr-01.
;;; rgr-html-collect-headings: oops; may not end at h1.  -- rgr, 2-May-01.
;;; rgr-html-headings-numbered-p: allow for initial markup.  -- rgr, 20-May-01.
;;; rgr-html-tags-implicitly-closed: new.  -- rgr, 6-Aug-02.
;;; rgr-html-parse-tag-attributes: allow for trailing "/", refuse to create
;;;	0-length symbols.  -- rgr, 14-Aug-02.
;;; add rgr-html-empty-tags, update rgr-html-tags-that-do-not-nest for the 21st
;;;	century.  -- rgr, 15-Dec-02.
;;;

(or (member 'sgml-mode features)
    (require 'html-helper-mode))

;; Compatibility with earlier emacs versions.  -- rgr, 2-Aug-96.
(or (fboundp 'buffer-substring-no-properties)
    (fset 'buffer-substring-no-properties 'buffer-substring))

;;;; Utilities.

;;; [some of these tag matching variables are semi-redundant, and should be
;;; consolidated or replaced with the rgr-html-parse-tag-attributes fn.  -- rgr,
;;; 4-Dec-97.]

(defconst rgr-heading-re
    (let ((whitespace "[ \t]"))
      (concat "^<h\\([0-9]\\)>" whitespace "*\\(.*\\)" whitespace "*</h\\1>"))
  ;; [this is bogus; it requires the whole heading to fit on one line.  -- rgr,
  ;; 23-Mar-98.]
  "Regular expression that matches headings, which must appear on lines
by themselves.  Tag nesting irregularities will cause headings to missed
entirely.")

(defvar rgr-html-tag-regexp (concat "<\\(/\\)?\\([-_a-zA-Z0-9!.]+\\)")
  "Regular expression for finding tags.  The presence of a slash must be
detectable by using (match-beginning 1) as a boolean, and the tag name
itself (minus the slash) must be the second subexpression.  [The '_' in
the name pattern is probably bogus.  -- rgr, 16-Apr-98.]")

(defvar rgr-html-looking-at-tag-regexp
	(concat "[ \t]*" rgr-html-tag-regexp)
  "Matches a tag name, with optional leading horizontal space (no
newlines).  The tag name itself (minus the slash) must be the second
subexpression.")

(defvar rgr-html-paragraph-regexp
	(concat "^" rgr-html-looking-at-tag-regexp "\\|^$\\|^\f")
  "Regular expression that matches the start of a paragraph, or a tag at
the start of a line (with optional whitespace).  The tag may or may not
mean a paragraph start; rgr-html-move-one-paragraph examines the tag to
see.")

(defconst rgr-html-empty-tags
          '(area base basefont br col frame
	    hr img input isindex link meta param)
  "Tags that can never have content.  In XML, they would usually appear
as 'empty tags', e.g. '<br/>', but HTML has no such notion, so they are
always just '<br>' and we shouldn't look for a close.")

(defconst rgr-html-tags-that-do-not-nest
          (append '(! option style script li dd dt
		    wbr		;; N1.0
		    embed	;; N2.0
		    spacer	;; N3.0b
		    )
		  rgr-html-empty-tags)
  "Tag names as symbols (not strings or regular expressions) in lower
case that never expect a </tag> to follow.")

(defconst rgr-html-tags-that-may-nest '(p a-name)
  "Tags where </tag> is optional.  But if any close is omitted, they
must all be.  Get rid of 'a-name' to require closes on '<a name=foo>'
tags.  Get rid of `p' to enforce HTML 3.0 containerization of paragraph
tags.")

(defvar rgr-html-tags-that-may-nest-never-do-p t
  "*Whether to consider rgr-html-tags-that-may-nest as never nesting.")

(defvar rgr-html-tags-implicitly-closed
  '((td (td th))
    (th (th td))
    (tr (tr th td) (th td))
    (table nil (tr th td)))
  ;; [used by rgr-html-collect-tag-data; feature still in development.  -- rgr,
  ;; 6-Aug-02.]
  "This specifies that, for example, a <tr> tag implicitly closes any
open <tr>, <th>, or <td> markup, and a </tr> closes any open <th> or
<td> markup.")

;;; General tag hackery.

(defun rgr-html-matched-tag-symbol ()
  ;; Given that we have just matched one of the rgr-html-*-regexp variables that
  ;; includes a tag, return the tag name as a symbol (after converting to lower
  ;; case).  Does not distinguish <a> tags.
  (let ((tag-string
	  ;; This must always have at least one character.
	  (downcase (buffer-substring-no-properties (match-beginning 2)
						    (match-end 2)))))
    (if (= (aref tag-string 0) ?\!)
	'!
	(intern tag-string))))

(defun rgr-html-matched-tag-name ()
  ;; Given that we've just matched rgr-html-tag-regexp, extract the tag name as
  ;; a symbol, and distinguish <a name=...> from <a href=...> by returning
  ;; a-name for the first case.  But note that we can't tell what </a> means in
  ;; this case; the caller must keep track of the last a tag seen.  [treatment
  ;; of comment tags is probably not optimal.  -- rgr, 4-Dec-97.]
  (let ((tag-name (rgr-html-matched-tag-symbol)))
    (if (and (eq tag-name 'a)
	     (save-excursion
	       ;; [we could parse the attributes instead, but that seems
	       ;; excessive; the caller may need to parse them anyway.  -- rgr,
	       ;; 4-Dec-97.]
	       (save-match-data
		 ;; We will normally already be here (the match-beginning) if
		 ;; searching backward, but not if searching forward.  [using
		 ;; forward-sexp to identify the end of the tag seems more
		 ;; reliable than parsing it ourselfves.  -- rgr, 26-May-04.]
		 (goto-char (match-beginning 0))
		 (forward-sexp 1)
		 (let ((end (point)) (result nil))
		   (goto-char (match-end 0))
		   (while (and (not result) (< (point) end))
		     (skip-chars-forward " \t\n")
		     (setq result (looking-at "name[ \t\n]*="))
		     (skip-chars-forward "^ \t\n"))
		   result))))
	'a-name
	tag-name)))

(defun rgr-html-looking-at-tag-p ()
  "If looking at a tag (as defined by rgr-html-looking-at-tag-regexp),
return it as a symbol (after converting to lower case)."
  (if (looking-at rgr-html-looking-at-tag-regexp)
      (rgr-html-matched-tag-symbol)))

(defun rgr-html-read-quoted-parameter-value ()
  (let* ((delimiter (char-after (point)))
	 (legal-char-set (concat (list ?^ delimiter)))
	 (start (progn (forward-char)
		       (point)))
	 (end (progn (skip-chars-forward legal-char-set)
		     (point))))
    (and (eq (char-after (point)) delimiter)
	 (forward-char))
    (buffer-substring start end))) 

(defun rgr-html-parse-tag-attributes ()
  ;; Assumes that point is just past the tag name.  Returns an alist of
  ;; (name-symbol . value-string), except that if name-symbol appears as a
  ;; boolean (i.e. without the "=value"), value-string will be the symbol t
  ;; instead.  On exit, point is left just past the closing ">".  May signal an
  ;; error if the tag is grossly malformed.  Names are always downcased and
  ;; interned, and we do not care whether names are repeated, except that they
  ;; are always returned in the order given.  -- rgr, 29-Nov-97.  [Syntax is
  ;; based on http://www.w3.org/TR/WD-html-lex/sgml.l (q.v.).  -- rgr,
  ;; 30-Mar-98.]
  (let ((result nil))
    (skip-chars-forward " \t\n")
    (while (and (not (eobp))
		(not (looking-at "/? *>")))
      (let* ((name-string (downcase (buffer-substring-no-properties
				      (point)
				      ;; [this doesn't check that the first
				      ;; char must be alphabetic.  -- rgr,
				      ;; 30-Mar-98.]
				      (progn (skip-chars-forward "-a-zA-Z0-9.")
					     (point)))))
	     (name (if (> (length name-string) 0)
		       (intern name-string)
		       (error "Zero-length attribute name.")))
	     (value t) (next-char nil))
	(skip-chars-forward " \t\n")
	(cond ((and (not (eobp))
		    (= (char-after (point)) ?=))
	        (forward-char)
	        (skip-chars-forward " \t\n")
	        (setq next-char (char-after (point)))
	        (cond ((eobp)
			(error "Missing end of tag."))
		      ((= next-char ?\>)
			(error "Missing attribute value."))
		      ((memq next-char '(?\' ?\"))
			(setq value (rgr-html-read-quoted-parameter-value)))
		      ((= next-char ?\")
			;; Assume that lisp syntax works . . . [no it doesn't;
			;; see above.  -- rgr, 30-Mar-98.]
			(setq value (read (current-buffer))))
		      ((looking-at "[-a-zA-Z0-9.]+")
			;; An SGML name_token.
			(goto-char (match-end 0))
		        (setq value (buffer-substring-no-properties
				      (match-beginning 0)
				      (point))))
		      ((= next-char ?<)
		        ;; the parser referenced above says "Unclosed tags not
		        ;; supported", but it's not clear what "supporting" this
		        ;; would mean.  -- rgr, 25-Apr-98.
			(error "Unclosed tag"))
		      (t
			(error "Illegal character '%c' in attribute value"
			       next-char)))))
	;; [the test is a hack for "-->", so we can get attributes out of
	;; comments.  allowing whitespace and an optional value does take
	;; considerable liberties with the syntax, but we shouldn't ever see any
	;; of these anyway.  -- rgr, 25-Apr-98.]
	(or (eq name '--)
	    (setq result (cons (cons name value) result))))
      ;; Set up for the next parameter.
      (skip-chars-forward " \t\n"))
    ;; Skip the closing ">".
    (if (looking-at "/? *>")
	(goto-char (match-end 0)))
    (nreverse result)))

;;; tag nesting support.

(defun rgr-html-tag-does-not-nest-p (tag-name)
  ;; Given a tag symbol, return non-nil if we do not expect it to nest.  Assumes
  ;; that <a> tags have been separated into a-name and a-href.  Note that this
  ;; is not as smart as rgr-html-tag-entry-make-report because we can't know if
  ;; (e.g.) </p> is ever used in this buffer.
  (or (memq tag-name rgr-html-tags-that-do-not-nest)
      (and rgr-html-tags-that-may-nest-never-do-p
	   (memq tag-name rgr-html-tags-that-may-nest))))

;;; rgr-html-forward-markup and support.

(defun rgr-html-forward-markup (&optional n markup-regexp mismatch-is-error-p)
  "Markup-oriented version of forward-sexp (q.v.).
Interactively, a numeric arg supplies the number of markup expressions N
past which to move; the sign indicates the direction.  The MARKUP-REGEXP
arg can be used to customize which markup is to be scanned; by default
the value of rgr-html-tag-regexp is used.  Handles errors Zmacs-style
\(i.e. like a Lisp Machine) in that if an unmatched close is encountered,
we move past it and stop immediately, no matter how many markup forms
were requested.  This can be treated as an error by supplying the
optional third MISMATCH-IS-ERROR-P arg.  But if the start or end of the
buffer is encountered, that is always an error."
  (interactive "p")
  (or n (setq n 1))
  (or markup-regexp (setq markup-regexp rgr-html-tag-regexp))
  (let* ((forward-p (>= n 0))
	 (re-searcher (if forward-p 're-search-forward 're-search-backward))
	 ;; Search state.
	 (last-a-tag nil)		;; is </a> for <a name=...> or href?
	 (n (abs n))
	 (nest 0))
    (while (and (> n 0)
		;; need this to detect popping up a nest level
		(>= nest 0))
      (or (funcall re-searcher markup-regexp nil 'move)
	  ;; [this may need to be more detailed.  -- rgr, 4-Dec-97.]
	  (error "No more markup."))
      (let ((open-p (not (match-beginning 1)))
	    (tag (rgr-html-matched-tag-name)))
	;; Skip the <...> business (how depends on direction).
	(cond (forward-p
		(goto-char (match-beginning 0))
		(forward-sexp)))
	;; open-p really means a markup tag for which we should increase the
	;; nesting depth (if it nests).  in the forward direction, that means
	;; the opens; in the reverse direction, we increment on closes and
	;; decrement on opens.
	(if (not forward-p)
	    (setq open-p (not open-p)))
	;; [this loses when going backwards.  -- rgr, 4-Dec-97.]  [see the
	;; ~/hacks/random/ice.html page for containerized a-name examples.  --
	;; rgr, 29-Jan-98.]
	(cond ((or (not forward-p) (not (memq tag '(a a-name)))))
	      (open-p (setq last-a-tag tag))
	      (last-a-tag (setq tag last-a-tag)))
	;; (message "tag %s last-a-tag %s" tag last-a-tag) (sit-for 1)
	(cond ((rgr-html-tag-does-not-nest-p tag)
		;; Treat a non-nesting tag at top level as an "atom", and count
		;; it against the number of forms we have to move.
		(if (zerop nest)
		    (setq n (1- n))))
	      (open-p
		(setq nest (1+ nest)))
	      (t
		(setq nest (1- nest))
		;; If nest is zero now, it must have been positive (since we
		;; just decremented it), so that means we've passed the matching
		;; close of a complete markup "sexp".
		(if (zerop nest)
		    (setq n (1- n)))))))
    ;; Figure out why we exited.  [could also check for other pathologies, like
    ;; insufficient number of expressions.  -- rgr, 4-Dec-97.]
    ;(message "nest %d n %d" nest n)
    (if (and (< nest 0)
	     (and mismatch-is-error-p (not (eq mismatch-is-error-p 'never))))
	(error "Containing markup ends prematurely."))
    (if (eq mismatch-is-error-p 'never)
	;; this is used by rgr-html-backward-up-markup, below.
	nest
	;; [useful return value?  -- rgr, 4-Dec-97.]
	n)))

(defun rgr-html-backward-markup (&optional n markup-regexp mismatch-is-error-p)
  "Markup-oriented version of backward-sexp (q.v.).
This is the same as rgr-html-forward-markup (invoked as
\\[rgr-html-forward-markup], q.v.), only a positive numeric arg (which
supplies the number of markup expressions N past which to move, and
defaults to 1) indicates backward motion.  The other args are the same.
[Note that the code is unable to distinguish <a name=...> from <a
href=...> when moving backward.  This won't bite you as long as your use
of </a> for <a name=...> is consistent -- rgr, 4-Dec-97.]"
  (interactive "p")
  (rgr-html-forward-markup (- (or n 1)) markup-regexp mismatch-is-error-p))

(defun rgr-html-backward-up-markup (&optional n markup-regexp)
  "Markup-oriented version of \\[backward-up-list] (q.v.).  This uses
rgr-html-forward-markup (\\[rgr-html-forward-markup], q.v.)  N times to
skip backward an arbitrary amount of markup, going up each time."
  (interactive "p")
  (or n (setq n 1))
  (if (< n 0)
      ;; [sigh.  -- rgr, 4-Dec-97.]
      (error "Sorry, this version doesn't allow a negative arg."))
  (while (> n 0)
    (let* ((last-point (point))
	   (nest (rgr-html-forward-markup -99999 markup-regexp 'never)))
      (cond ((>= nest 0)
	      ;; [this doesn't quite seem to work . . .  -- rgr, 4-Dec-97.]
	      (goto-char last-point)
	      (error "At top level."))))
    (setq n (1- n))))

(defun rgr-html-kill-markup (arg)
  ;; Code stolen from same.  -- rgr, 21-Mar-98.
  "Like \\[kill-sexp] in Lisp, but kills the markup following the cursor.
With argument, kill that many markup expressions after the cursor.
Negative arg -N means kill N markup expressions before the cursor."
  (interactive "p")
  (let ((opoint (point)))
    (rgr-html-forward-markup arg)
    (kill-region opoint (point))))

(defun rgr-html-indent-markup ()
  "Like \\[indent-sexp] (C-M-q in Lisp mode, similarly in C mode).
Assuming the current line is indented correctly, indent the rest of the
lines in the next matching markup (e.g. <tr>...</tr>) correspondingly.
Does not move point or adjust the position of line breaks."
  (interactive)
  (let ((start (point))
	(end (save-excursion
	       (rgr-html-forward-markup)
	       (point)))
	(indent-command (or (key-binding "\t")
			    'html-helper-indent-command))
	(n-lines-indented 0))
    (forward-line)
    (while (and (not (eobp))
		(< (point) end))
      (funcall indent-command)
      (setq n-lines-indented (1+ n-lines-indented))
      (forward-line))
    (goto-char start)
    (message "Indented %d line%s."
	     n-lines-indented (if (= n-lines-indented 1) "" "s"))))

(defvar rgr-html-tags-needing-newline-after-close '(html head body
						    h1 h2 h3 h4 h5 h6
						    pre blockquote
						    ol ul dl)
  "Names of tags after which we should add a newline when we close.")

(defvar rgr-html-tags-needing-fresh-line-before-close '(html head body
							pre blockquote
							ol ul dl)
  "Names of tags which should start a line when closed.")

(defun rgr-html-insert-or-skip-newline ()
  ;; Go to the start of the next line, doing so by inserting a newline if the
  ;; next line is not empty.
  (cond ((looking-at "\n\n")
	  ;; (message "Found double newline") (sit-for 1)
	  (forward-char))
	(t
	  (insert "\n"))))

(defun rgr-html-close-markup (n)
  "Insert a close tag for the last open markup, and indent.
If given a numeric argument, close the last N open tags.  Uses
rgr-html-tags-needing-fresh-line-before-close and
rgr-html-tags-needing-newline-after-close to decide how to pretty-up the
surrounding whitespace."
  (interactive "p")
  (let ((resume (point)) (tag nil))
    (while (and (> n 0)
		(setq tag (save-excursion
			    (goto-char resume)
			    (rgr-html-backward-up-markup)
			    (prog1 (rgr-html-matched-tag-name)
			      (setq resume (point))))))
      (if (and (memq tag rgr-html-tags-needing-fresh-line-before-close)
	       (save-excursion
		 (skip-chars-backward " \t")
		 (not (bolp))))
	  (rgr-html-insert-or-skip-newline))
      (insert "</" (symbol-name tag) ">")
      (html-helper-indent)
      (if (memq tag rgr-html-tags-needing-newline-after-close)
	  (rgr-html-insert-or-skip-newline))
      (setq n (1- n)))
    (and tag
	 (html-helper-indent))))

(defun rgr-html-join (connector set)
  ;; Like the perl join operator.  Expects a connector string, and a list of
  ;; strings.
  (if (null set)
      ""
      (let ((result (list (car set)))
	    (tail (cdr set)))
	(while tail
	  (setq result (cons (car tail) (cons connector result)))
	  (setq tail (cdr tail)))
	(apply (function concat) (nreverse result)))))

(defun rgr-html-tag-alternative-regexp (tags &optional parens-p)
  ;; Make a regular expression that matches the given tag starts (but it's only
  ;; a complete regexp if you supply parens-p non-nil).
  (let ((result (rgr-html-join "\\>\\|<" tags)))
    (if parens-p
	(concat "\\(<" result "\\>\\)")
	(concat "<" result "\\>"))))

;;;; Fixing tag regular expressions (and hence indentation).

;;;###autoload
(defun rgr-html-fix-regexps ()
  "Repair the tag regular expressions, replacing (e.g.) \"<li>\" with
\"<li\\\\>\".  This makes indentation deal with parameterized tags
properly."
  (interactive)
  ;; was "<li>\\|<dt>\\|<dd>\\|<option\\|<th>\\|<td>"
  ;; [not in version 2.0.  -- rgr, 11-Aug-99.]
  (setq html-helper-any-list-item-start
	(rgr-html-tag-alternative-regexp '("li" "dt" "dd" "option" "th" "td")))
  ;; [only in 2.0.  -- rgr, 11-Aug-99.]
  (setq html-helper-any-list-item html-helper-any-list-item-start)
  ;; was "<dl>\\|<ul>\\|<ol>\\|<menu>\\|<dir>\\|<select\\|<table\\|<tr>"
  (setq html-helper-any-list-start
	(rgr-html-tag-alternative-regexp '("dl" "ul" "ol" "menu" "dir"
					   "select" "table" "tr")))
  ;; was "</dl>\\|</ul>\\|</ol>\\|</menu>\\|</dir>"
  (setq html-helper-any-list-end
	(concat "</dl>\\|</ul>\\|</ol>\\|</menu>\\|</dir>"
		"\\|</select>\\|</table>\\|</tr>"))
  ;; re-evaluate other regexp variables to catch new values
  (setq html-helper-any-list
	(format "\\(%s\\)\\|\\(%s\\)\\|\\(%s\\)%s"
		html-helper-any-list-start
		html-helper-any-list-end
		html-helper-any-list-item-start
		;; [only in 2.0.  -- rgr, 11-Aug-99.]
		(if (boundp 'html-helper-any-list-item-end)
		    (concat "\\|\\(" html-helper-any-list-item-end "\\)")
		    "")))
  ;; [only in 2.0.  -- rgr, 11-Aug-99.]
  (and (boundp 'html-helper-indentation-list)
       (setq html-helper-indentation-list
	     (format "\\(%s\\)\\|\\(%s\\)\\|\\(%s\\)"
		     html-helper-any-list-start
		     html-helper-any-list-end
		     html-helper-any-list-item-start)))
  ;; [semi-kludge: while we're at it, fix the empty-buffer template.  -- rgr,
  ;; 15-Sep-99.]
  (let ((tail (member "<body>\n" html-helper-new-buffer-template)))
    (and tail
	 ;; [should be "text=black", or whatever.  -- rgr, 15-Sep-99.]
	 (setcar tail "<body bgcolor=white>\n")))
  (let ((tail (member "\n\n<hr>\n" html-helper-new-buffer-template)))
    (and tail
	 ;; [i don't like text to butt up against the hr.  -- rgr, 27-Sep-99.]
	 (setcar tail "\n<p>\n<hr>\n"))))

;;;; HTML `paragraphs'.

;;; See the rgr-html-forward-paragraph documentation for an explanation of why I
;;; put the `paragraphs' in quotes.  -- rgr, 11-Mar-96.

(defvar rgr-html-non-paragraph-tags
	'(em strong dfn code samp kbd var cite
	  big small	;; HTML 3.0(?)
	  tt i b
	  sub sup	;; N3.0b
	  u s		;; HTML 3.0 (underline & strikethrough)
	  strike	;; HTML 3.2 (instead of <s>..</s>)
	  blink		;; N1.0+
	  font		;; N1.0/N2.0
	  a		;; but not a-name, by default.
	  br
	  nobr wbr	;; N1.0
	  )
  "Tags which do not affect paragraphing, always in lower case.  (These
are called 'text level elements' by the HTML 3.2 specification; see the
http://www.w3.org/TR/REC-html32.html page for details).  Add a-name if
you want to override the default interpretation of <a name=...> as a
paragraph tag.  I have tried to keep this list relatively small; add to
it if you think it needs more.")

(defvar rgr-html-paragraph-start-tags '(p li dd dt)
  "Tags which start paragraphs (i.e. belong on the first line of a
paragraph).  Used by \\[rgr-html-fill-paragraph] to decide whether a
line starting with this tag should be filled as part of the paragraph.
Tags not on this list or on rgr-html-non-paragraph-tags should not have
text creep up after them (which is what happens to these guys).")

(defun rgr-html-move-one-paragraph (&optional backward-p)
  ;; Returns non-nil if we moved any.  Helper for rgr-html-forward-paragraph;
  ;; don't call this directly.  -- rgr, 11-Mar-96.
  (let* ((re-searcher (if backward-p 're-search-backward 're-search-forward))
	 (limit-p (if backward-p 'bobp 'eobp))
	 (regexp rgr-html-paragraph-regexp)
	 (moved-p (funcall re-searcher regexp nil 'move)))
    (while (and (not (funcall limit-p))
		(match-beginning 2)
		;; Found a tag.
		(let ((tag-name (rgr-html-matched-tag-name)))
		  (memq tag-name rgr-html-non-paragraph-tags)))
      (funcall re-searcher regexp nil 'move))
    moved-p))

;;;###autoload
(defun rgr-html-forward-paragraph (&optional arg)
  "Move forward to the end of the HTML paragraph, where `paragraph' is
interpreted in terms of the HTML source.  With arg N, do it N times; a
negative arg -N means move backward N paragraphs.

   A paragraph is delimited by either one or more blank lines (which
separate them), or an HTML tag at the start of the line (possibly with
whitespace in front of it) that may cause the browser to start a new
paragraph.  This is defined broadly as any tag that appears on the
`rgr-html-non-paragraph-tags' list, which is initially just those tags
that do font changes (e.g. <b>, <em>, etc.).  Anchors are handled
specially; <a name=\"...\"> starts a paragraph; <a href=\"...\"> and
</a> do not.

   Note that tags that start paragraphs, including <p> itself, are not
considered to actually do so unless they are at the beginning of an HTML
source line.

   The implementation is conceptually compatible with the default
forward-paragraph (\\[forward-paragraph]) command.  It uses the
`paragraph-separate' regexp to identify lines (usually blank) that
separate paragraphs, but replaces `paragraph-start' with code that looks
for either a separator or an HTML tag as defined above.  As for
\\[forward-paragraph], a paragraph end is the beginning of a line which
is not part of the paragraph to which the end of the previous line
belongs, or the end of the buffer."
  ;; Hacked version of forward-paragraph that uses an HTML-compatible notion of
  ;; paragraph, and loses the fill-prefix and regexp-based paragraph-start
  ;; support.  -- rgr, 11-Mar-96.
  (interactive "p")
  (or arg (setq arg 1))
  (while (and (< arg 0) (not (bobp)))
    (if (and (not (looking-at paragraph-separate))
	     (re-search-backward "^\n" (max (1- (point)) (point-min)) t))
	nil
      ;; Move back over paragraph-separating lines.
      (forward-char -1) (beginning-of-line)
      (while (and (not (bobp)) (looking-at paragraph-separate))
	(forward-line -1))
      (if (bobp)
	  nil
	;; Go to end of the previous (non-separating) line.
	(end-of-line)
	;; Search back for line that starts or separates paragraphs.
	(cond ((rgr-html-move-one-paragraph t)
		;; Found one.
		;; Move forward over paragraph separators.
		;; We know this cannot reach the place we started
		;; because we know we moved back over a non-separator.
		(while (and (not (eobp)) (looking-at paragraph-separate))
		  (forward-line 1))
		(if (eq (char-after (- (point) 2)) ?\n)
		    (forward-line -1)))
	      (t
		;; No starter or separator line => use buffer beg.
		(goto-char (point-min))))))
    (setq arg (1+ arg)))
  (while (and (> arg 0) (not (eobp)))
    (beginning-of-line)
    (while (prog1 (and (not (eobp))
		       (looking-at paragraph-separate))
		  (forward-line 1)))
    (if (rgr-html-move-one-paragraph)
	(goto-char (match-beginning 0))
	(goto-char (point-max)))
    (setq arg (1- arg))))

;;;###autoload
(defun rgr-html-backward-paragraph (&optional count)
  "Move backward to the start of the HTML paragraph, where `paragraph'
is interpreted in terms of the HTML source.  With arg N, do it N times;
a negative arg -N means move forward N paragraphs."
  (interactive "p")
  (rgr-html-forward-paragraph (- (or count 1))))

;;;###autoload
(defun rgr-html-fill-paragraph (&optional justify-p)
  "Fill a paragraph as defined by the rgr-html-forward-paragraph command
\(presently bound to \\[rgr-html-forward-paragraph].  See the
rgr-html-forward-paragraph documentation for details."
  (interactive "P")
  (let ((before (point)) (start nil))
    (save-excursion
      (rgr-html-forward-paragraph)
      ;; [the fill-paragraph definition has (or (bolp) (newline 1)) here; is
      ;; that redundant wrt what rgr-html-forward-paragraph does?  -- rgr,
      ;; 14-Mar-96.]
      (let ((end (point)))
	(rgr-html-forward-paragraph -1)
	(cond ((member (rgr-html-looking-at-tag-p)
		       rgr-html-paragraph-start-tags)
		;; These are tags we expect to be part of a paragraph.
		)
	      ((progn (forward-line)
		      (eq (point) end))
		;; Not normally a paragraph start tag, but there's only one
		;; line.  Play it as it lies.
		(forward-line -1)))
	(setq start (point))
	(goto-char before)
	(fill-region-as-paragraph start end justify-p)))))

;;;; ol/ul/dl stuff.

(defvar rgr-html-list-regexp
        (let ((whitespace "[ \t\n]*"))
	  (concat "<" whitespace "\\(/" whitespace
		  "\\)?\\(ol\\|ul\\|dl\\)\\>")))

(defvar rgr-html-list-or-li-regexp
        (let ((whitespace "[ \t\n]*"))
	  (concat "<" whitespace "\\(/" whitespace
		  "\\)?\\(ol\\|ul\\|dl\\|li\\|dl\\|dt\\)\\>")))

(defun rgr-html-find-containing-list ()
  (let ((start (point)) begin)
    (rgr-html-backward-up-markup 1 rgr-html-list-regexp)
    (setq begin (point))
    ;; [this just says "no more markup" if it fails.  -- rgr, 22-Feb-98.]
    (rgr-html-forward-markup)
    (and (> (point) start)
	 (cons begin (point)))))

(defun rgr-html-forward-li (&optional n end)
  "Move forward to the next <li> tag of the current list (i.e. ignoring
any <li> items within nested lists).  If there aren't any, this just
leaves you after the last list close tag.  This needs a special command
because people almost never use </li> tags."
  (interactive "p")
  (or n (setq n 1))
  (and (< n 0)
       (error "%S can't handle negative args." 'rgr-html-forward-li))
  (let ((tag nil))
    (while (and (> n 0)
		(re-search-forward rgr-html-list-or-li-regexp end t))
      (setq tag (rgr-html-matched-tag-symbol))
      (cond ((memq tag '(li dt dd))
	      (setq n (1- n)))
	    ;; must be (memq tag '(ol ul dl))
	    ((match-beginning 1)
	      ;; it's equivalent to "containing expression ends prematurely.
	      (setq tag nil end (point)))
	    (t
	      ;; skip embedded lists.
	      (goto-char (match-beginning 0))
	      (rgr-html-forward-markup))))
    '(and (looking-at "[ \t\n]*>")
	  (goto-char (match-end 0)))
    (cond ((match-beginning 0)
	    (goto-char (match-beginning 0))
	    (forward-sexp)))
    tag))

(defun rgr-html-ul-to-dl ()
  "When within a <ul>...</ul> (or <ol>...</ol>), replace each <li> with <dt>.
If the clause contains a '--' surrounded by whitespace, then replace the
'--' with <dd>.  Each replacement attempts to preserve indentation."
  (interactive)
  (save-excursion
    (let* ((pair (or (rgr-html-find-containing-list)
		     (error "No containing list.")))
	   (start (car pair))
	   (end (set-marker (make-marker) (cdr pair))))
      '(message "Got %S" pair)
      (goto-char start)
      (forward-sexp)	;; skip opening <ul> or whatever.
      (let ((tag nil))
	(while (setq tag (rgr-html-forward-li 1 end))
	  ;; Process tag
	  ;; (message "Got %S at %S" tag (point)) (sit-for 1)
	  (replace-match "<dt") 
	  (cond ((re-search-forward "[ \t\n]+--[ \t\n]+"
				    (save-excursion
				      (rgr-html-forward-li 1 end)
				      (point))
				    t)
		  (replace-match "\n<dd> ")
		  (html-helper-indent-command)
		  (rgr-html-fill-paragraph)))))
      ;; Now replace the <ul> and </ul>.
      (goto-char start)
      (if (looking-at rgr-html-list-regexp)
	  (replace-match "dl" nil nil nil 2))
      ;; This is why end has to be a marker.
      (goto-char end)
      (forward-sexp -1)
      (if (looking-at rgr-html-list-regexp)
	  (replace-match "dl" nil nil nil 2)))))

;;;; Generating a table of contents.

(defconst rgr-table-of-contents-start-tag "<!-- hhmtoc start -->\n"
  "Tag line indicating the start of an automatically-generated table of
contents.  Must include its own trailing newline.")
(defconst rgr-table-of-contents-end-tag "<!-- hhmtoc end -->\n"
  "Tag line indicating the end of an automatically-generated table of
contents.  Must include its own trailing newline.")

(defun rgr-print-indent (to)
  ;; Dumb print-oriented version of indent-to (which operates on the current
  ;; buffer at point).  Assumes we are starting at the right margin.
  (while (>= to 8)
    (princ "\t")
    (setq to (- to 8)))
  (while (>= to 1)
    (princ " ")
    (setq to (1- to))))

;; [old implementation.  -- rgr, 23-Apr-01.]
'(defun rgr-collect-headings (use-ul-p)
  ;; Scan the buffer for headings, putting the result into a temp buffer, and
  ;; returning that.  Helper for the rgr-html-make-toc command
  (save-excursion
    (let* ((standard-output (save-excursion
			      (set-buffer (get-buffer-create "*HTML headings*"))
			      (erase-buffer)
			      (buffer-disable-undo)
			      (current-buffer)))
	   (tag (if use-ul-p "ul" "ol"))
	   (open-list (format "<%s>\n" tag))
	   (close-list (format "</%s>\n" tag)))
      (goto-char (point-min))
      (let* (;; Parameters.  This looks like what tabbing does for you.
	     (initial-indent html-helper-basic-offset)
	     (continue-indent html-helper-item-continue-indent)
	     (delta-indent (+ initial-indent continue-indent))
	     ;; Working variables.  level-stack is so we can treat a nesting of
	     ;; h3 within h1 (i.e. <h1>/<h3>/<h1>) without having to go down two
	     ;; levels.
	     (level-stack nil) (indent initial-indent) (last-level nil))
	(princ open-list)
	(while (re-search-forward rgr-heading-re nil t)
	  (let ((level (string-to-int (buffer-substring-no-properties
				        (match-beginning 1)
					(match-end 1))))
		(heading (buffer-substring-no-properties (match-beginning 2)
							 (match-end 2)))
		(anchor-name nil))
	    ;; Look for an existing anchor.
	    (save-excursion
	      (forward-line -1)
	      (while (and (not (bobp))
			  (looking-at "^[ \t]*<\\(hr\\|p\\)>"))
		(forward-line -1))
	      (if (looking-at "[ \t]*<a\\>")
		  (let* ((attributes (progn (goto-char (match-end 0))
					    (rgr-html-parse-tag-attributes)))
			 (name (cdr (assq 'name attributes))))
		    (if (stringp name)
			(setq anchor-name name)))))
	    ;; Check for increase in nesting level.
	    (cond ((null last-level)
		    ;; Initialization, done on the fly so that if the first
		    ;; heading level is h2 or h3, we don't wind up with empty
		    ;; list constructs.  -- rgr, 19-Jan-98.
		    (setq last-level level))
		  ((> level last-level)
		    (rgr-print-indent (+ indent continue-indent))
		    (princ open-list)
		    (setq indent (+ indent delta-indent))
		    (setq level-stack (cons last-level level-stack))
		    (setq last-level level)))
	    ;; Check for decrease in nesting level (which will fail if we just
	    ;; saw an increase).
	    (while (and level-stack (< level last-level))
	      (setq indent (- indent delta-indent))
	      (rgr-print-indent (+ indent continue-indent))
	      (princ close-list)
	      (setq last-level (car level-stack))
	      (setq level-stack (cdr level-stack)))
	    ;; Finally, do the item.
	    (rgr-print-indent indent)
	    (princ "<li> ")
	    (if anchor-name
		(princ (concat "<a href=\"#" anchor-name "\">")))
	    (princ heading)
	    (if anchor-name
		(princ "</a>"))
	    (terpri)))
	;; Deal with dangling nesting depth (i.e. the last section isn't <h1>).
	(while level-stack
	  (setq indent (- indent delta-indent))
	  (rgr-print-indent (+ indent continue-indent))
	  (princ close-list)
	  (setq level-stack (cdr level-stack)))
	;; And close off the top-level list.
	(princ close-list))
      standard-output)))

(defun rgr-html-make-heading (level heading &optional anchor-name)
  (list level heading anchor-name nil))

(defsubst rgr-html-heading-level (heading) (car heading))
(defsubst rgr-html-heading-text (heading) (car (cdr heading)))
(defsubst rgr-html-heading-tag (heading) (nth 2 heading))
(defsubst rgr-html-heading-subheadings (heading) (nth 3 heading))

(defsubst rgr-html-set-heading-subheadings (heading new-value)
  (setcar (nthcdr 3 heading) new-value))

(defun rgr-html-collect-headings ()
  ;; Scan the buffer for headings, returning them as a list of nested (level
  ;; text tag subheading-list) lists.  Helper for the rgr-html-make-toc
  ;; command
  (goto-char (point-min))
  (let (;; Working variables.  level-stack is so we can treat a nesting of h3
	;; within h1 (i.e. <h1>/<h3>/<h1>) without having to go down two levels.
	(level-stack (list (rgr-html-make-heading 0 "")))
	(last-heading nil)	;; our effective sibling.
	)
    (while (re-search-forward rgr-heading-re nil t)
      (let ((level (string-to-int (buffer-substring-no-properties
				   (match-beginning 1)
				   (match-end 1))))
	    (heading-text (buffer-substring-no-properties (match-beginning 2)
							  (match-end 2)))
	    (anchor-name nil) (heading nil))
	;; Look for an existing anchor.
	(save-excursion
	  (forward-line -1)
	  (while (and (not (bobp))
		      (looking-at "^[ \t]*<\\(hr\\|p\\)>"))
	    (forward-line -1))
	  (if (looking-at "[ \t]*<a\\>")
	      (let* ((attributes (progn (goto-char (match-end 0))
					(rgr-html-parse-tag-attributes)))
		     (name (cdr (assq 'name attributes))))
		(if (stringp name)
		    (setq anchor-name name)))))
	(setq heading (rgr-html-make-heading level heading-text anchor-name))
	;; Check for increase in nesting level, in which case the last guy
	;; becomes our parent.  We insist on a previous heading so that if the
	;; first heading level is h2 or h3, we don't wind up with empty list
	;; constructs.  -- rgr, 19-Jan-98.
	(if (and last-heading
		 (> level (rgr-html-heading-level last-heading)))
	    (setq level-stack (cons last-heading level-stack)))
	;; Check for decrease in nesting level (which will fail if we just saw
	;; an increase).
	(while (and level-stack
		    (<= level (rgr-html-heading-level (car level-stack))))
	  (setq level-stack (cdr level-stack)))
	;; Finally, add the item.
	(let ((parent (or (car level-stack)
			  (error "internal error: popped too far."))))
	  (rgr-html-set-heading-subheadings
	    parent
	    (nconc (rgr-html-heading-subheadings parent) (list heading)))
	  (setq last-heading heading))))
    (and level-stack
	 (car (last level-stack)))))

(defun rgr-html-headings-numbered-p (heading)
  ;; return t iff all subheadings start with a digit, including whitespace but
  ;; not including initial markup.
  (let ((all-p t) (tail (rgr-html-heading-subheadings heading)))
    (while (and all-p tail)
      (if (not (string-match "^\\(<[^>]*>\\)*[0-9]"
			     (rgr-html-heading-text (car tail))))
	  (setq all-p nil))
      (setq tail (cdr tail)))
    all-p))

(defun rgr-html-insert-heading-subheadings
       (heading &optional never-number-p indent)
  ;; Recursive inserter of a heading's subheadings, a helper function for
  ;; rgr-html-make-toc (below).
  (or indent (setq indent 0))
  (let* ((tag (if (or never-number-p
		      (rgr-html-headings-numbered-p heading))
		  "ul"
		  "ol"))
	 (tail (rgr-html-heading-subheadings heading)))
    (indent-to-column indent)
    (insert "<" tag ">\n")
    (while tail
      (let* ((subhead (car tail))
	     (anchor-name (rgr-html-heading-tag subhead)))
	(indent-to-column (+ indent html-helper-basic-offset))
	(insert "<li> "
		(if anchor-name
		    (concat "<a href=\"#" anchor-name "\">")
		    "")
		(rgr-html-heading-text subhead)
		(if anchor-name "</a>" "")
		"\n")
	(if (rgr-html-heading-subheadings subhead)
	    (rgr-html-insert-heading-subheadings
	      subhead never-number-p
	      (+ indent html-helper-basic-offset
		 html-helper-item-continue-indent))))
      (setq tail (cdr tail))) 
    (indent-to-column indent)
    (insert "</" tag ">\n")))

;;;###autoload
(defun rgr-html-make-toc (&optional use-ul-p)
  "Insert a table of contents generated from <h#></h#> lines.  If this
is the first invocation in this buffer, the TOC is inserted at point,
and you will be asked to confirm this.  Otherwise, the previous TOC is
replaced with a new one.

   If items appear to be numbered, or the command is given a numeric
argument, the items are generated within nested <ul> tags; otherwise,
they are within <ol> tags.

   In order to be seen, the markup for section headers must appear at
the start of the line, and the entire header must appear on one line.
\(You should doublecheck these constraints if the code seems to be
mysteriously ignoring sections.)  If an <a name=\"tag\"> appears on the
previous line, the TOC entry for that section will be wrapped in a
hypertext reference."
  (interactive "P")
  (save-excursion
    (let ((make-new-p nil) (original-point (point)) (table-start nil)
	  (headings nil))
      (goto-char (point-min))
      (setq table-start (search-forward rgr-table-of-contents-start-tag nil t))
      (cond (table-start)
	    ((progn (goto-char original-point)
		    (yes-or-no-p
		      "Buffer has no table of contents; insert at point? "))
	      (setq make-new-p t))
	    (t
	      (error "Aborted.")))
      (setq headings (rgr-html-collect-headings))
      ;; Make sure we have both tags, with no old TOC in between.
      (cond (make-new-p
	      (goto-char original-point)
	      (insert rgr-table-of-contents-start-tag)
	      (setq table-start (point))
	      (insert rgr-table-of-contents-end-tag))
	    (t
	      (goto-char table-start)
	      (let ((table-end
		      (save-excursion
			(and (search-forward rgr-table-of-contents-end-tag
					     nil t)
			     (match-beginning 0)))))
		(cond (table-end
			(delete-region table-start table-end))
		      (t
			;; If we can't find it, insert a new one right here.
			(insert rgr-table-of-contents-end-tag))))))
      ;; Add the new TOC.
      (goto-char table-start)
      (rgr-html-insert-heading-subheadings headings use-ul-p))))

;;;; Turning C-h m output into HTML documentation stubs.

;;;###autoload
(defun rgr-html-make-documentation-stub ()
  (interactive)
  (insert "\n<p><b>Commands:</b>\n<ul>\n")
  (while (re-search-forward "^\\([^ \t\n][^\t\n]*\\)\t+\\(.*\\)$" nil t)
    (let ((command-name (match-string 2))
	  (keys (match-string 1)))
      (save-match-data
	(while (string-match "ESC " keys)
	  (setq keys (replace-match "M-" nil nil keys)))
	(while (string-match "M-C-" keys)
	  (setq keys (replace-match "C-M-" nil nil keys)))
	(while (string-match " " keys)
	  (setq keys (replace-match "&nbsp;" nil nil keys))))
      (replace-match (concat "  <li> <b><tt>" keys "</tt></b> (<tt>"
			     command-name "</tt>) --")
		     t t)))
  (insert "\n</ul>\n"))

;;;; Tag ends.

(defvar rgr-html-menu-items
	'(["Check tag nesting" rgr-html-check-tag-nesting t]
	  ["Check hrefs" rgr-html-check-buffer-hrefs t]
	  ["Fix hrefs" rgr-html-fix-buffer-hrefs t]
	  ["Flush file anchors" rgr-html-flush-file-anchors t]
	  ["Update buffer anchors" rgr-html-update-buffer-anchors t]
	  ["Update TOC" rgr-html-make-toc t])
  "Commands to add to the 'HTML' menu.  Must be defined here, or autoloaded.")

(defun rgr-html-menu-item-present-in-list-p (item list)
  ;; equivalent to (find item list :test #'menu-item-equal) in CL.
  (let ((tail list) (result nil))
    (while tail
      (let ((elt (car tail)))
	(if (or (equal item elt)
		(and (vectorp item) (vectorp elt)
		     (eq (aref item 1) (aref elt 1))))
	    (setq result elt tail nil)
	    (setq tail (cdr tail)))))
    result))

(defun rgr-html-install-menu-items ()
  ;; Install menu items for rgr-html-check-tag-nesting, etc., in the order
  ;; defined by the rgr-html-menu-items variable.
  (let ((new nil))
    ;; Exclude redefined items.
    (let ((tail html-helper-novice-menu))
      (while tail
	(or (rgr-html-menu-item-present-in-list-p (car tail)
						  rgr-html-menu-items)
	    (setq new (cons (car tail) new)))
	(setq tail (cdr tail))))
    ;; Include only defined items.
    (let ((tail rgr-html-menu-items))
      (while tail
	(let ((item (car tail)))
	  (if (or (not (vectorp item))
		  (fboundp (aref item 1)))
	      (setq new (cons item new))))
	(setq tail (cdr tail))))
    (setq html-helper-novice-menu (nreverse new))
    ;; [i would have assumed this is not necessary if done by a load
    ;; hook, but that's not the case.  -- rgr, 19-Mar-96.]
    (html-helper-rebuild-menu)))

(defun rgr-html-define-commands-internal (mode-map)
  ;; internal function
  (define-key mode-map "\M-q" 'rgr-html-fill-paragraph)
  (define-key mode-map "\M-}" 'rgr-html-forward-paragraph)
  (define-key mode-map "\M-{" 'rgr-html-backward-paragraph)
  (define-key mode-map "\C-\M-q" 'rgr-html-indent-markup)
  ;; [these next two shadow some default markup insertion in html-helper-mode.
  ;; -- rgr, 4-Dec-97.]
  (define-key mode-map "\C-c\C-f" 'rgr-html-forward-markup)
  (define-key mode-map "\C-c\C-b" 'rgr-html-backward-markup)
  (define-key mode-map "\C-c\C-u" 'rgr-html-backward-up-markup)
  (define-key mode-map "\C-c\C-k" 'rgr-html-kill-markup)
  (define-key mode-map "\C-c\C-l" 'rgr-html-forward-li)
  (define-key mode-map "\C-cn" 'rgr-html-check-tag-nesting)
  (define-key mode-map "\C-ct" 'rgr-html-make-toc)
  (define-key mode-map "\C-c/" 'rgr-html-close-markup)
  ;; I'm not real happy about these binding choices.
  (define-key mode-map "\C-chc" 'rgr-html-check-buffer-hrefs)
  (define-key mode-map "\C-chf" 'rgr-html-fix-buffer-hrefs)
  (define-key mode-map "\C-chd" 'rgr-html-check-directory-hrefs)
  (define-key mode-map "\C-cau" 'rgr-html-update-buffer-anchors)
  (define-key mode-map "\C-caf" 'rgr-html-flush-file-anchors))

;;;###autoload
(defun rgr-html-define-commands ()
  "Bind the rgr-html-* commands to the usual keys.  Use this as a hook
function if you want it:

	(add-hook 'html-helper-load-hook 'rgr-html-define-commands)

In any case, you probably also want to do the following:

	(add-hook 'html-helper-load-hook 'rgr-html-fix-regexps)

since the defaults are wrong."
  ;; Do this here in case the user has changed user-mail-address in his/her init
  ;; file.
  (and user-mail-address
       (setq html-helper-address-string
	     (concat "<a href=\"mailto:" user-mail-address "\">"
		     (user-full-name) "\n\t<tt>&lt;"
		     user-mail-address "&gt;</tt></a>")))
  (rgr-html-define-commands-internal html-helper-mode-map)
  (and (boundp 'html-helper-novice-menu)
       (or (member (car rgr-html-menu-items) html-helper-novice-menu)
	   (rgr-html-install-menu-items))))

(defun rgr-html-do-auto-fill ()
  ;; Just do auto fill, without adaptive-fill-mode stuff.  [This used to be the
  ;; same as rgr-do-auto-fill, but that needs to rebind indent-line-function,
  ;; which makes it screw up after <li>.  -- rgr, 13-Jan-00.]
  (let ((adaptive-fill-mode nil))
    (do-auto-fill)))

;;;###autoload
(defun rgr-html-helper-mode-hook ()
  "This does html-helper-mode to my taste.  You probably want to use
rgr-html-define-commands as a load hook instead.  -- rgr, 14-Oct-97."
  ;; html-helper-mode runs text-mode-hook before html-helper-mode-hook, so we
  ;; may have turned on rgr-do-auto-fill, which is too thorough in its
  ;; squelching of adaptive-fill-mode.  -- rgr, 15-Dec-99.  [and do-auto-fill is
  ;; too adaptive, so use rgr-html-do-auto-fill instead.  -- rgr, 13-Jan-00.]
  (and (memq auto-fill-function '(do-auto-fill rgr-do-auto-fill))
       (setq auto-fill-function 'rgr-html-do-auto-fill))
  ;; Because I don't need this bound to something that inserts "<hr>".
  (define-key html-helper-mode-map "\C-c=" 'discus-quick-source-compare)
  ;; And much prefer the default C-M-f and C-M-b bindings.
  (define-key html-helper-mode-map "\M-\C-f" 'forward-sexp)
  (define-key html-helper-mode-map "\M-\C-b" 'backward-sexp)
  ;; Allow for tags at the end of sentences (but do so in a mode specific way).
  ;; The regular expression means "<end-char> { <close> | <tag> } <whitespace>",
  ;; where { | } means zero or more of the alternation, and <end-char>, <close>,
  ;; and <whitespace> are not altered in meaning from the original sentence-end.
  ;; [Hack <end-char> to include ":", because I don't like M-q messing with
  ;; these.  -- rgr, 8-Feb-96.]
  (make-local-variable 'sentence-end)
  (setq sentence-end
	;; "[.?!]\\(<[/a-zA-Z0-9]*>\\)*[]\"')}]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"
	"[:.?!]\\(<[/a-zA-Z0-9]+>\\|[]\"')}]\\)*\\($\\| $\\|\t\\|  \\)[ \t\n]*")
  ;; This makes <li> continuation lines prettier, since I like to put a space
  ;; after the <li>.
  (setq html-helper-item-continue-indent 5))

(provide 'rgr-html-hacks)

